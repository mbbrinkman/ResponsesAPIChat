<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>OpenRouter Responses API Chat</title>
    <!-- PDF.js loaded on-demand when first PDF is uploaded -->
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100dvh; /* Use dynamic viewport height for mobile */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tabs {
            display: flex;
            background: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
            padding: 0 12px;
        }

        .tab {
            padding: 12px 20px;
            cursor: pointer;
            border: none;
            background: none;
            color: #888;
            font-size: 14px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #e0e0e0;
        }

        .tab.active {
            color: #e0e0e0;
            border-bottom-color: #4a9eff;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
            flex-direction: column;
        }

        .tab-content.active {
            display: flex;
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .message {
            margin-bottom: 20px;
            max-width: 85%;
        }

        .message.user {
            margin-left: auto;
            background: #2a4a7a;
            padding: 12px 16px;
            border-radius: 12px;
        }

        .message.assistant {
            background: #2a2a2a;
            padding: 12px 16px;
            border-radius: 12px;
        }

        .message.thinking {
            background: #3a2a1a;
            padding: 12px 16px;
            border-radius: 12px;
            border-left: 3px solid #ff8c42;
            opacity: 0.85;
            font-style: italic;
        }

        .thinking-toggle {
            background: #3a2a1a;
            border: 1px solid #4a4a4a;
            color: #ff8c42;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            margin: 8px 0;
            display: inline-block;
            user-select: none;
        }

        .thinking-toggle:hover {
            background: #4a3a2a;
        }

        .thinking-content {
            background: #3a2a1a;
            padding: 10px;
            border-radius: 6px;
            border-left: 3px solid #ff8c42;
            margin: 8px 0;
            font-style: italic;
            font-size: 13px;
            color: #d0d0d0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .thinking-content.collapsed {
            display: none;
        }

        .inline-thinking-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #3a2a1a;
            border-radius: 4px;
            font-size: 11px;
            color: #ff8c42;
            font-style: italic;
            margin: 4px 0;
        }

        .inline-thinking-indicator .dot {
            width: 4px;
            height: 4px;
            background: #ff8c42;
            border-radius: 50%;
            animation: thinking-pulse 1.4s infinite;
        }

        .inline-thinking-indicator .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .inline-thinking-indicator .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes thinking-pulse {
            0%, 60%, 100% {
                opacity: 0.3;
            }
            30% {
                opacity: 1;
            }
        }

        .typing-indicator {
            background: #2a2a2a;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 85%;
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 8px;
            opacity: 0.7;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-indicator .dot {
            width: 8px;
            height: 8px;
            background: #4a9eff;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-indicator .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .message-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
        }

        /* List styling - override pre-wrap to fix spacing */
        .message-content ol,
        .message-content ul {
            white-space: normal;
            margin: 8px 0;
            padding-left: 24px;
        }

        .message-content ol {
            list-style-type: decimal;
        }

        .message-content ul {
            list-style-type: disc;
        }

        .message-content li {
            white-space: pre-wrap;
            margin: 4px 0;
        }

        .message-content a {
            color: #4a9eff;
            text-decoration: none;
        }

        .message-content a:hover {
            text-decoration: underline;
        }

        /* Plain spacing - no extra margins from markdown elements */
        .message-content p,
        .message-content blockquote,
        .message-content h1, .message-content h2, .message-content h3,
        .message-content h4, .message-content h5, .message-content h6,
        .message-content hr {
            margin: 0;
        }

        .message-content blockquote {
            padding-left: 12px;
            border-left: 3px solid #4a9eff;
            color: #aaa;
        }

        .message-content hr {
            border: none;
            border-top: 1px solid #3a3a3a;
        }

        .message-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
        }

        .message-actions button {
            background: #3a3a3a;
            border: none;
            color: #888;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .message-actions button:hover {
            background: #4a4a4a;
            color: #e0e0e0;
        }

        .file-preview {
            margin-top: 8px;
            max-width: 100%;
        }

        .file-preview img, .file-preview video {
            max-width: 100%;
            border-radius: 8px;
        }

        .file-info {
            background: #3a3a3a;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 8px;
        }

        #chat-input-area {
            background: #2a2a2a;
            border-top: 1px solid #3a3a3a;
            padding: 16px;
        }

        .input-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-controls, .send-controls {
            display: flex;
            gap: 8px;
        }

        .input-controls {
            width: 100%;
        }

        .input-controls button {
            flex: 1;
        }

        .send-controls {
            width: 100%;
        }

        .send-controls button {
            flex: 1;
        }

        #message-input {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 44px;
            max-height: 200px;
        }

        #message-input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        #message-input.editing {
            border-color: #f0ad4e;
        }

        #edit-indicator {
            display: none;
            color: #f0ad4e;
            font-size: 12px;
            margin-bottom: 4px;
            align-items: center;
            gap: 8px;
        }

        #edit-indicator.visible {
            display: flex;
        }

        #edit-indicator button {
            background: transparent;
            border: none;
            color: #888;
            padding: 0;
            cursor: pointer;
            font-size: 12px;
            text-decoration: underline;
        }

        #edit-indicator button:hover {
            color: #e0e0e0;
        }

        #prefill-indicator {
            display: none;
            color: #9b59b6;
            font-size: 12px;
            margin-bottom: 4px;
            align-items: center;
            gap: 8px;
        }

        #prefill-indicator.visible {
            display: flex;
        }

        #prefill-indicator button {
            background: transparent;
            border: none;
            color: #888;
            padding: 0;
            cursor: pointer;
            font-size: 12px;
            text-decoration: underline;
        }

        #prefill-indicator button:hover {
            color: #e0e0e0;
        }

        #message-input.prefilling {
            border-color: #9b59b6;
        }

        .editable-name {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .editable-name:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .name-editor {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .name-editor input {
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            width: 120px;
        }

        .name-editor button {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }

        .name-editor button:hover {
            background: #4a4a4a;
        }

        .role-switch-btn {
            background: transparent;
            border: 1px solid #4a4a4a;
            color: #888;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 4px;
        }

        .role-switch-btn:hover {
            background: #3a3a3a;
            color: #e0e0e0;
        }

        .file-upload-btn, .model-select, #send-btn {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .model-select {
            min-width: 150px;
        }

        #send-btn {
            background: #4a9eff;
            border-color: #4a9eff;
            font-weight: 600;
        }

        #send-btn:hover {
            background: #3a8eef;
        }

        #send-btn:disabled {
            background: #3a3a3a;
            color: #666;
            cursor: not-allowed;
        }

        #stop-btn {
            background: #ff6b6b;
            border-color: #ff6b6b;
            font-weight: 600;
            display: none;
        }

        #stop-btn:hover {
            background: #ff5252;
        }

        #prefill-btn {
            background: #9b59b6;
            border-color: #9b59b6;
            font-weight: 600;
        }

        #prefill-btn:hover {
            background: #8e44ad;
        }

        #prefill-btn:disabled {
            background: #3a3a3a;
            color: #666;
            cursor: not-allowed;
        }

        .attached-files {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .attached-file {
            background: #3a3a3a;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .attached-file button {
            background: #4a4a4a;
            border: none;
            color: #e0e0e0;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
        }

        #model-picker-popup {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .popup-content {
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .popup-content h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #e0e0e0;
        }

        #model-checkboxes {
            margin-bottom: 15px;
        }

        #model-checkboxes label {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            align-items: start;
            padding: 8px;
            margin-bottom: 5px;
            background: #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
        }

        #model-checkboxes label:hover {
            background: #4a4a4a;
        }

        #model-checkboxes input[type="checkbox"] {
            margin: 3px 0 0 0;
        }

        .model-info {
            min-width: 0;
        }

        .model-name {
            font-weight: 600;
            color: #e0e0e0;
        }

        .system-prompt-preview {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
            word-wrap: break-word;
        }

        .mode-selector {
            margin-bottom: 15px;
            padding: 10px;
            background: #3a3a3a;
            border-radius: 4px;
        }

        .mode-selector label {
            display: inline-block;
            margin-right: 15px;
            color: #e0e0e0;
        }

        .mode-selector input[type="radio"] {
            margin-right: 5px;
        }

        .settings-container, .prompts-container, .history-container {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .settings-section {
            margin-bottom: 24px;
        }

        .settings-section h3 {
            margin-bottom: 12px;
            color: #4a9eff;
        }

        textarea, input, select {
            width: 100%;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 10px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        textarea {
            min-height: 200px;
            resize: vertical;
        }

        button.primary {
            background: #4a9eff;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 12px;
        }

        button.primary:hover {
            background: #3a8eef;
        }

        .prompt-item, .history-item {
            background: #2a2a2a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            border: 1px solid #3a3a3a;
        }

        .prompt-item h4 {
            margin-bottom: 8px;
            color: #4a9eff;
        }

        .prompt-actions, .history-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
        }

        .prompt-actions button, .history-actions button {
            background: #3a3a3a;
            border: none;
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .prompt-actions button:hover, .history-actions button:hover {
            background: #4a4a4a;
        }

        .error {
            background: #4a2a2a;
            border-left: 3px solid #ff4a4a;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
        }

        #file-input {
            display: none;
        }

        @media (max-width: 768px) {
            .message {
                max-width: 95%;
            }

            .input-row {
                flex-wrap: wrap;
            }

            .model-select {
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="tabs">
        <button class="tab active" data-tab="chat">Chat</button>
        <button class="tab" data-tab="history">History</button>
        <button class="tab" data-tab="help">Help</button>
        <button class="tab" data-tab="settings">Settings</button>
    </div>

    <div id="chat-tab" class="tab-content active">
        <div id="chat-messages"></div>
        <div id="chat-input-area">
            <div class="attached-files" id="attached-files"></div>
            <div class="input-row">
                <input type="file" id="file-input" multiple accept="*/*">
                <div class="input-controls">
                    <button class="file-upload-btn" onclick="document.getElementById('file-input').click()">Attach</button>
                    <button class="model-select" id="model-picker-btn">Select Models</button>
                    <button class="model-select" onclick="newChat()">New Chat</button>
                </div>
                <div id="edit-indicator">
                    <span>editing</span>
                    <button onclick="cancelEditMode()">cancel</button>
                </div>
                <div id="prefill-indicator">
                    <span>prefilling assistant response</span>
                    <button onclick="cancelPrefillMode()">cancel</button>
                </div>
                <textarea id="message-input" placeholder="Type a message... (Click Send button to send)"></textarea>
                <div class="send-controls">
                    <button id="send-btn">Send</button>
                    <button id="stop-btn">Stop</button>
                    <button id="auto-btn" style="display: none;">Start Auto</button>
                    <button id="prefill-btn" title="Start an assistant response that models will continue">Prefill</button>
                </div>
            </div>
            <div id="model-picker-popup" style="display: none;">
                <div class="popup-content">
                    <h3>Select Models</h3>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #e0e0e0;">Active System Prompt:</label>
                        <select id="picker-prompt-select" style="width: 100%; padding: 8px; background: #3a3a3a; border: 1px solid #4a4a4a; color: #e0e0e0; border-radius: 4px;">
                            <option value="">None (no system prompt)</option>
                        </select>
                    </div>
                    <div id="model-checkboxes"></div>
                    <div class="mode-selector">
                        <label>Mode:</label>
                        <label><input type="radio" name="model-mode" value="parallel" checked> Parallel</label>
                        <label><input type="radio" name="model-mode" value="serial"> Serial</label>
                        <label><input type="radio" name="model-mode" value="rotating"> Rotating</label>
                        <label><input type="radio" name="model-mode" value="autonomous"> Autonomous</label>
                    </div>
                    <div class="mode-selector" style="margin-top: 10px;">
                        <label for="iteration-count">Iterations:</label>
                        <input type="number" id="iteration-count" min="1" max="100" value="1" style="width: 80px; padding: 4px 8px; background: #2a2a2a; border: 1px solid #4a4a4a; color: #e0e0e0; border-radius: 4px;">
                        <span style="font-size: 12px; color: #888; margin-left: 8px;">How many times models should reply</span>
                    </div>
                    <div class="mode-selector" style="margin-top: 10px;">
                        <label for="response-delay">Response Delay:</label>
                        <input type="number" id="response-delay" min="0" max="10000" step="100" value="1000" style="width: 80px; padding: 4px 8px; background: #2a2a2a; border: 1px solid #4a4a4a; color: #e0e0e0; border-radius: 4px;">
                        <span style="font-size: 12px; color: #888; margin-left: 8px;">ms delay between responses (Serial/Rotating/Autonomous)</span>
                    </div>
                    <div class="mode-selector" style="margin-top: 10px;">
                        <label for="history-limit">Message History Limit:</label>
                        <input type="number" id="history-limit" min="0" max="1000" value="0" style="width: 80px; padding: 4px 8px; background: #2a2a2a; border: 1px solid #4a4a4a; color: #e0e0e0; border-radius: 4px;">
                        <span style="font-size: 12px; color: #888; margin-left: 8px;">0 = all messages</span>
                        <div style="font-size: 11px; color: #666; margin-top: 4px; margin-left: 24px;">
                            Parallel mode: Sends last N messages per model separately<br>
                            Other modes: Sends last N messages (model-agnostic)
                        </div>
                    </div>
                    <div class="mode-selector" style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="include-files-checkbox" style="width: auto;">
                            <span>Include files in message history</span>
                        </label>
                    </div>
                    <div class="mode-selector" style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="enable-identity-checkbox" style="width: auto;">
                            <span>Enable model identity injection</span>
                        </label>
                    </div>
                    <div class="mode-selector" style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="background-audio-checkbox" style="width: auto;">
                            <span>Keep generating in background (iOS – best effort only; may still pause when screen locks)</span>
                        </label>
                    </div>
                    <div class="mode-selector" style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="extended-thinking-checkbox" style="width: auto;">
                            <span>Enable extended thinking</span>
                        </label>
                        <div style="margin-left: 28px; margin-top: 8px; display: flex; align-items: center; gap: 8px;">
                            <label for="thinking-effort" style="font-size: 13px; color: #aaa;">Effort:</label>
                            <select id="thinking-effort" style="background: #2a2a2a; color: #e0e0e0; border: 1px solid #4a4a4a; padding: 4px 8px; border-radius: 4px;">
                                <option value="low">Low</option>
                                <option value="medium">Medium</option>
                                <option value="high" selected>High</option>
                            </select>
                        </div>
                    </div>
                    <div class="mode-selector" style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="latex-rendering-checkbox" style="width: auto;">
                            <span>Enable LaTeX rendering (loads external JS)</span>
                        </label>
                    </div>
                    <div class="mode-selector" style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="markdown-rendering-checkbox" style="width: auto;">
                            <span>Enable Markdown rendering (loads external JS)</span>
                        </label>
                    </div>
                    <button onclick="closeModelPicker()">Done</button>
                </div>
            </div>
        </div>
    </div>

    <div id="history-tab" class="tab-content">
        <div class="history-container">
            <div class="settings-section">
                <h3>Conversation History</h3>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="primary" onclick="exportConversation()">Export History</button>
                    <button class="primary" onclick="document.getElementById('import-history-input').click()">Import History</button>
                    <button class="primary" onclick="clearHistory()">Clear All History</button>
                </div>
                <input type="file" id="import-history-input" accept=".json" style="display: none;" onchange="importHistory(event)">
            </div>
            <div id="history-list"></div>
        </div>
    </div>

    <div id="help-tab" class="tab-content">
        <div class="settings-container">
            <div class="settings-section">
                <h2>OpenRouter Responses API Chat - Help & Guide</h2>

                <h3>Quick Start</h3>
                <ol>
                    <li><strong>Add OpenRouter API Key:</strong> Go to Settings → Add API Key section (get your key from openrouter.ai)</li>
                    <li><strong>Browse Models:</strong> Go to Settings → Browse OpenRouter Models → Click "Load Models" to see all available models</li>
                    <li><strong>Add Models:</strong> Click any model from the browser to auto-populate the Add New Model form, or manually add model configuration</li>
                    <li><strong>Select Models:</strong> Click "Select Models" button, check the models you want to use. Use the number input to select multiple instances of the same model (1-10).</li>
                    <li><strong>Choose Mode & Iterations:</strong> In model picker, select Parallel/Serial/Rotating/Autonomous and set how many iterations (1-100)</li>
                    <li><strong>Chat:</strong> Type your message and click Send!</li>
                </ol>

                <h3>Model Browser</h3>
                <p>The Browse OpenRouter Models section fetches the live model catalog from OpenRouter:</p>
                <ul>
                    <li><strong>Load Models:</strong> Click to fetch all available models</li>
                    <li><strong>Search:</strong> Filter models by name, ID, or description</li>
                    <li><strong>Sort:</strong> Sort by date (newest first), name, or context length</li>
                    <li><strong>Select:</strong> Click any model to auto-fill the Add New Model form</li>
                </ul>
                <p>Each model shows context length, pricing, and release date to help you choose.</p>

                <h3>Model Configuration</h3>
                <p>Each model is defined by a JSON configuration with NO outer braces. Example:</p>
                <pre style="background: #1a1a1a; padding: 12px; border-radius: 6px; overflow-x: auto;">"endpoint": "https://openrouter.ai/api/v1/responses",
"model_id": "anthropic/claude-3.5-sonnet",
"api_key_id": "123456",
"system_prompt": "",
"max_output_tokens": null,
"temperature": 1.0</pre>

                <h4>Available OpenRouter Models</h4>
                <p>You can use any model from OpenRouter that supports the Responses API. Popular options include:</p>
                <ul>
                    <li><code>anthropic/claude-3.5-sonnet</code> - Claude 3.5 Sonnet</li>
                    <li><code>openai/gpt-4o</code> - GPT-4o</li>
                    <li><code>google/gemini-pro</code> - Google Gemini Pro</li>
                    <li><code>meta-llama/llama-3-70b-instruct</code> - Llama 3 70B</li>
                    <li>...and many more at <a href="https://openrouter.ai/models" target="_blank" style="color: #4a9eff;">openrouter.ai/models</a></li>
                </ul>

                <h4>Per-Model System Prompts</h4>
                <p>Set <code>"system_prompt": "Your prompt here"</code> in each model's config to give it a unique personality.</p>

                <h4>Global System Prompt Override</h4>
                <p>Use the "Active System Prompt" dropdown in the model picker to temporarily override all models' prompts.</p>

                <h3>Multi-Model Modes</h3>
                <ul>
                    <li><strong>Parallel:</strong> All selected models respond independently to your message. Each only sees your messages, not other models' responses.</li>
                    <li><strong>Serial:</strong> Models respond one after another. Each model sees all previous messages including other models' responses.</li>
                    <li><strong>Rotating:</strong> Like Serial, but the order rotates each turn (1,2,3 → 3,1,2 → 2,3,1 → repeat).</li>
                    <li><strong>Autonomous:</strong> Models converse with each other without human input. Click "Start Auto" to begin.</li>
                </ul>

                <h3>Iterations</h3>
                <p>You can set the number of iterations (1-100) to control how many times models reply:</p>
                <ul>
                    <li><strong>Parallel:</strong> All models respond N times in parallel (e.g., 2 iterations = 2 rounds of all models responding simultaneously)</li>
                    <li><strong>Serial:</strong> The complete sequence of models responds N times (e.g., 3 iterations with 2 models = model1, model2, model1, model2, model1, model2)</li>
                    <li><strong>Rotating:</strong> The rotated sequence repeats N times with order continuing to rotate each iteration</li>
                    <li><strong>Autonomous:</strong> Each model responds exactly N times (e.g., 10 iterations with 3 models = 30 total responses, 10 per model)</li>
                </ul>

                <h3>Flattened Participant Structure</h3>
                <p>In multi-model conversations (Serial, Rotating, Autonomous), all participants are treated equally with no hierarchy:</p>
                <ul>
                    <li><strong>Equal Participants:</strong> Your messages are prefixed with your identifier (e.g., "User said: hello"), just like model messages (e.g., "Claude said: hi").</li>
                    <li><strong>No Special Treatment:</strong> Models receive no indication that you are different from other participants. Everyone is simply a named participant in the conversation.</li>
                    <li><strong>Customizable Identity:</strong> Set your identifier in Settings → User Identifier (default: "Human"). Use any name you prefer to shape your role in the conversation.</li>
                </ul>
                <p><strong>Mode-Specific Behavior:</strong></p>
                <ul>
                    <li><strong>Parallel:</strong> Each model converses independently with you. Your messages are not prefixed since there's only one other participant.</li>
                    <li><strong>Serial/Rotating:</strong> All participants (you and all models) are listed equally. Messages are prefixed with participant identifiers.</li>
                    <li><strong>Autonomous:</strong> Models converse with each other without your participation.</li>
                </ul>
                <p><strong>Multiple Instances:</strong> You can select multiple instances of the same model by using the number input next to each model in the picker. The model name is simply a chat identifier to distinguish between different instances - multiple instances of the same underlying model can participate with different names (e.g., "GPT-4 Debater 1" and "GPT-4 Debater 2").</p>

                <h3>About OpenRouter Responses API</h3>
                <p>This app uses OpenRouter's Responses API, providing access to 100+ AI models through a modern streaming API:</p>
                <ul>
                    <li><strong>Anthropic:</strong> Claude models (Sonnet, Opus, Haiku)</li>
                    <li><strong>OpenAI:</strong> GPT-4o, GPT-4, O1, and more</li>
                    <li><strong>Google:</strong> Gemini models</li>
                    <li><strong>Meta:</strong> Llama models</li>
                    <li><strong>Mistral, Cohere, and many others</strong></li>
                </ul>
                <p>Visit <a href="https://openrouter.ai" target="_blank" style="color: #4a9eff;">openrouter.ai</a> to get your API key and browse available models.</p>

                <h3>Advanced Features</h3>
                <h4>Edit AI Responses</h4>
                <p>Click "Edit" button below any AI response to manually modify it before continuing the conversation.</p>

                <h4>Regenerate Responses</h4>
                <p>Click "Regenerate" to have the same model create a different response.</p>

                <h4>Continue Responses</h4>
                <p>Click "Continue" on any AI response to have the model extend/finish that response. Useful when a response was cut off or you want more detail.</p>

                <h4>Prefill Mode</h4>
                <p>Click "Prefill" to start typing the beginning of an AI response. The model will continue from where you left off. Great for guiding the model's response style or format.</p>

                <h4>Edit Names</h4>
                <p>Click on any participant name (user or model) in the chat to edit it. This lets you customize how participants are identified in the conversation.</p>

                <h4>Role Switching</h4>
                <p>Click "→ User" or "→ Assistant" buttons next to any message to convert it between user and assistant roles. This is useful for restructuring conversations or creating custom dialogue flows.</p>

                <h4>Edit User Messages</h4>
                <p>Click "Edit" button on your own messages to revise and branch the conversation from that point.</p>

                <h4>File Attachments</h4>
                <p>Click the "Attach" button to attach files. Supported file types:</p>
                <ul style="margin-left: 20px; margin-top: 8px;">
                    <li><strong>Images:</strong> Sent as visual data to vision-capable models</li>
                    <li><strong>PDFs:</strong> Text content is automatically extracted and sent to the model</li>
                    <li><strong>Text files:</strong> Content is read and sent to the model (.txt, .md, .json, .csv, .xml, code files, etc.)</li>
                    <li><strong>Other files:</strong> File name is mentioned (content extraction not supported)</li>
                </ul>
                <p style="margin-top: 8px;">Files are kept in context and will be included when you "Edit & Resend" messages.</p>

                <h4>Image Generation</h4>
                <p>The application supports receiving images from image generation models:</p>
                <ul>
                    <li>Use models with "image" in their output modalities (check model browser or openrouter.ai/models)</li>
                    <li>Request image generation in your message (e.g., "draw a sunset")</li>
                    <li>Generated images appear automatically in the response</li>
                    <li>Multiple images per response are supported</li>
                    <li>Images are displayed inline below the text content</li>
                </ul>

                <h4>OpenRouter Responses API Parameters (All Optional)</h4>
                <p>Customize your model behavior with these parameters (set to null to use defaults):</p>

                <h5 style="margin-top: 16px; color: #4a9eff;">Sampling Parameters</h5>
                <ul>
                    <li><code>temperature</code> (0.0-2.0): Randomness/creativity level. Lower = more deterministic, higher = more creative.</li>
                    <li><code>max_output_tokens</code>: Maximum tokens in response. Set based on expected response length.</li>
                    <li><code>top_p</code> (0.0-1.0): Nucleus sampling - limits choices to tokens whose probabilities sum to P.</li>
                    <li><code>top_k</code>: Limits choices to top K most likely tokens. Value of 1 = always pick most likely.</li>
                    <li><code>frequency_penalty</code> (-2.0 to 2.0): Reduce word repetition based on frequency in text.</li>
                    <li><code>presence_penalty</code> (-2.0 to 2.0): Encourage topic diversity by penalizing tokens already present.</li>
                    <li><code>seed</code>: Integer for deterministic/reproducible outputs (not guaranteed for all models).</li>
                    <li><code>stop</code>: Array of sequences that will stop generation (e.g., ["END", "\n\n"]).</li>
                </ul>

                <h5 style="margin-top: 16px; color: #4a9eff;">Tool Calling</h5>
                <ul>
                    <li><code>tools</code>: Array of function definitions the model can call. Each tool has type, name, description, and parameters.</li>
                    <li><code>tool_choice</code>: Control tool usage - "auto" (model decides), "none" (disabled), "required" (must use), or specific tool object.</li>
                    <li><code>parallel_tool_calls</code>: Boolean to allow/disallow simultaneous tool invocations.</li>
                </ul>

                <h5 style="margin-top: 16px; color: #4a9eff;">Output Format</h5>
                <ul>
                    <li><code>text</code>: Configure output format. Options:
                        <ul style="margin-top: 4px;">
                            <li><code>{"format": {"type": "text"}}</code> - Default text output</li>
                            <li><code>{"format": {"type": "json_object"}}</code> - JSON mode</li>
                            <li><code>{"format": {"type": "json_schema", "name": "...", "schema": {...}}}</code> - Structured output</li>
                            <li><code>{"verbosity": "low"|"medium"|"high"}</code> - Control response length</li>
                        </ul>
                    </li>
                </ul>

                <h5 style="margin-top: 16px; color: #4a9eff;">Reasoning/Extended Thinking</h5>
                <ul>
                    <li><code>reasoning</code>: Configure extended thinking for supported models (O1, Claude, etc.):
                        <ul style="margin-top: 4px;">
                            <li><code>effort</code>: "none" | "minimal" | "low" | "medium" | "high" | "xhigh"</li>
                            <li><code>summary</code>: "auto" | "concise" | "detailed"</li>
                            <li><code>max_tokens</code>: Limit reasoning tokens</li>
                            <li><code>enabled</code>: Boolean to enable/disable</li>
                        </ul>
                    </li>
                </ul>

                <h5 style="margin-top: 16px; color: #4a9eff;">Provider Routing</h5>
                <ul>
                    <li><code>provider</code>: Control which providers handle your request:
                        <ul style="margin-top: 4px;">
                            <li><code>allow_fallbacks</code>: Boolean (default: true) - Allow fallback to other providers</li>
                            <li><code>require_parameters</code>: Boolean - Only route to providers supporting all params</li>
                            <li><code>data_collection</code>: "allow" | "deny" - Control data collection</li>
                            <li><code>zdr</code>: Boolean - Restrict to Zero Data Retention endpoints</li>
                            <li><code>order</code>: Array of provider slugs for preference order</li>
                            <li><code>only</code>: Array of provider slugs to exclusively use</li>
                            <li><code>ignore</code>: Array of provider slugs to avoid</li>
                            <li><code>quantizations</code>: Array of acceptable quantizations ("int4", "int8", "fp8", "fp16", etc.)</li>
                            <li><code>sort</code>: "price" | "throughput" | "latency" - How to rank providers</li>
                            <li><code>max_price</code>: {prompt, completion, image, request} - Price limits per million tokens</li>
                        </ul>
                    </li>
                </ul>

                <h5 style="margin-top: 16px; color: #4a9eff;">Plugins</h5>
                <ul>
                    <li><code>plugins</code>: Array of optional plugins:
                        <ul style="margin-top: 4px;">
                            <li><code>{"id": "web"}</code> - Web search plugin with options: enabled, max_results, search_prompt, engine ("native"|"exa")</li>
                            <li><code>{"id": "moderation"}</code> - Content moderation plugin</li>
                            <li><code>{"id": "file-parser"}</code> - File parsing with pdf engine options ("mistral-ocr"|"pdf-text"|"native")</li>
                            <li><code>{"id": "response-healing"}</code> - Auto-fix malformed responses</li>
                        </ul>
                    </li>
                </ul>

                <h5 style="margin-top: 16px; color: #4a9eff;">Tracking & Storage</h5>
                <ul>
                    <li><code>user</code>: End-user identifier (max 128 chars) for abuse tracking.</li>
                    <li><code>session_id</code>: Unique ID (max 128 chars) for grouping related requests.</li>
                    <li><code>store</code>: Boolean - Store conversation server-side for future reference.</li>
                    <li><code>metadata</code>: Object with custom key-value string pairs for your tracking.</li>
                </ul>

                <h5 style="margin-top: 16px; color: #4a9eff;">Other</h5>
                <ul>
                    <li><code>timeout</code>: Request timeout in milliseconds (default: 120000 = 2 minutes). Increase for reasoning models.</li>
                </ul>

                <h3>Data Storage</h3>
                <p>All data is stored locally in your browser using IndexedDB:</p>
                <ul>
                    <li><strong>Storage Capacity:</strong> 50 MB to several GB (varies by browser), much larger than typical localStorage limits</li>
                    <li><strong>Images Supported:</strong> Store conversations with multiple images without quota issues</li>
                    <li><strong>Mobile Friendly:</strong> Works reliably on mobile devices including iPhone/iPad</li>
                    <li><strong>Privacy:</strong> All data stays on your device, nothing sent to servers except OpenRouter API calls</li>
                </ul>

                <h3>Data Management</h3>
                <h4>Export Data</h4>
                <p>Settings → Export Data creates a JSON file with all your models, API keys, prompts, and current conversation.</p>

                <h4>Import Data</h4>
                <p>Settings → Import Data loads a previously exported JSON file.</p>

                <h4>Clear History</h4>
                <p>History → Clear All History removes all saved conversations.</p>

                <h3>Tips & Best Practices</h3>
                <ul>
                    <li><strong>API Keys:</strong> Create separate API key entries for different projects/purposes</li>
                    <li><strong>System Prompts:</strong> Save reusable prompts (e.g., "Coding Assistant", "Creative Writer")</li>
                    <li><strong>Model Names:</strong> Use descriptive names like "GPT-4 Creative" vs "GPT-4 Analytical"</li>
                    <li><strong>Temperature:</strong> Lower (0.0-0.7) for factual/coding, higher (0.8-1.5) for creative</li>
                    <li><strong>Modes:</strong> Use Parallel for comparing responses, Serial for debate/discussion</li>
                </ul>

                <h3>Troubleshooting</h3>
                <p><strong>Messages not sending:</strong> Check browser console (F12) for errors, verify API key is correct</p>
                <p><strong>Images not working:</strong> Ensure you're using a vision-capable model (Claude 3+, GPT-4V, Gemini Pro Vision). Images are always sent with the most recent message.</p>
                <p><strong>Mode not updating:</strong> Hard refresh (Ctrl+Shift+R or Cmd+Shift+R)</p>
                <p><strong>Model deleted:</strong> Can't regenerate old messages from deleted models</p>
                <p><strong>Multiple images on mobile:</strong> IndexedDB storage allows unlimited images even on mobile devices like iPhone</p>

                <h3>Source Code & License</h3>
                <p>This application is open source and available on GitHub:</p>
                <p><a href="https://github.com/mbbrinkman/ResponsesAPIChat" target="_blank" style="color: #4a9eff;">https://github.com/mbbrinkman/ResponsesAPIChat</a></p>
                <p><strong>License:</strong> CC0 (Public Domain)</p>
                <p>You are free to use, modify, distribute, and do basically whatever you want with this code. No attribution required.</p>
            </div>
        </div>
    </div>

    <div id="settings-tab" class="tab-content">
        <div class="settings-container">
            <div class="settings-section">
                <h3>User Identifier</h3>
                <p style="font-size: 13px; color: #888; margin-bottom: 12px;">Customize how you're identified in multi-model conversations (default: "Human")</p>
                <input type="text" id="user-identifier-input" placeholder="Enter your identifier (e.g., User, Moderator, etc.)" style="margin-bottom: 8px;">
                <button class="primary" onclick="saveUserIdentifier()">Save Identifier</button>
            </div>
            <div class="settings-section">
                <h3>Add New Prompt</h3>
                <input type="text" id="new-prompt-name" placeholder="Prompt name" style="margin-bottom: 8px;">
                <textarea id="new-prompt-content" placeholder="System prompt content..."></textarea>
                <button class="primary" onclick="addSystemPrompt()">Add Prompt</button>
            </div>
            <div class="settings-section">
                <h3>Saved Prompts</h3>
                <div id="prompts-list"></div>
            </div>
            <div class="settings-section">
                <h3>Add OpenRouter API Key</h3>
                <p style="font-size: 13px; color: #888; margin-bottom: 12px;">Get your API key from <a href="https://openrouter.ai/keys" target="_blank" style="color: #4a9eff;">openrouter.ai/keys</a></p>
                <input type="text" id="new-key-name" placeholder="Key name (e.g., Personal, Work)" style="margin-bottom: 8px;">
                <input type="password" id="new-key-value" placeholder="Paste your OpenRouter API key here" style="margin-bottom: 8px;">
                <button class="primary" onclick="addApiKey()">Add API Key</button>
            </div>
            <div class="settings-section">
                <h3>Saved API Keys</h3>
                <div id="api-keys-list"></div>
            </div>
            <div class="settings-section">
                <h3>Browse OpenRouter Models</h3>
                <p style="font-size: 13px; color: #888; margin-bottom: 12px;">Fetch and search available models from OpenRouter</p>
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <button class="primary" onclick="fetchOpenRouterModels()">Load Models</button>
                    <select id="model-sort" onchange="sortAndDisplayModels()" style="width: 150px;">
                        <option value="date">Sort by Date</option>
                        <option value="name">Sort by Name</option>
                        <option value="context">Sort by Context</option>
                    </select>
                </div>
                <div style="margin-bottom: 12px;">
                    <input type="text" id="model-search" placeholder="Search models..." style="width: 100%;" oninput="filterModels()">
                </div>
                <div id="models-browser" style="max-height: 400px; overflow-y: auto; background: #1a1a1a; padding: 12px; border-radius: 6px; display: none;">
                    <p style="color: #888;">Click "Load Models" to browse available models</p>
                </div>
            </div>
            <div class="settings-section">
                <h3>Add New Model</h3>
                <input type="text" id="new-model-name" placeholder="Model name (e.g., Claude 3.5 Sonnet)" style="margin-bottom: 8px;">
                <textarea id="new-model-config" placeholder="Model configuration (JSON)..." style="min-height: 250px;"></textarea>
                <button class="primary" onclick="addModel()">Add Model</button>
            </div>
            <div class="settings-section">
                <h3>Saved Models</h3>
                <div id="models-list"></div>
            </div>
            <div class="settings-section">
                <h3>Export/Import Data</h3>
                <button class="primary" onclick="exportData()">Export All Data</button>
                <button class="primary" onclick="document.getElementById('import-input').click()">Import Data</button>
                <input type="file" id="import-input" accept=".json" style="display: none;" onchange="importData(event)">
            </div>
        </div>
    </div>

    <script>
        // State
        let models = [];
        let apiKeys = [];
        let systemPrompts = [];
        let activePromptId = null;
        let editingModelIndex = null; // Track which model is being edited
        let editingPromptId = null; // Track which prompt is being edited
        let currentConversation = [];
        let attachedFiles = [];
        let editingMessageIndex = null;
        let isPrefilling = false; // Whether we're in prefill mode (starting an assistant response)
        let isStreaming = false;
        let userStoppedGeneration = false; // Flag to prevent subsequent models from responding after stop is pressed
        // Structure: [{modelIndex: 0, count: 3}, {modelIndex: 1, count: 2}] instead of [0,0,0,1,1]
        let selectedModelEntries = [];
        let multiModelMode = 'parallel';
        let rotationIndex = 0;
        let isAutonomousRunning = false;
        let autonomousRounds = 0;
        let iterationCount = 1;
        let messageHistoryLimit = 0; // 0 means all messages
        let includeFilesInHistory = false;
        let responseDelay = 1000; // Delay in ms between responses in serial/rotating/autonomous modes
        let enableModelIdentity = true; // Whether to inject model identity into system prompts
        let enableBackgroundAudio = false; // Whether to play silent audio to keep app alive on iOS
        let enableExtendedThinking = false; // Whether to enable extended thinking/reasoning mode
        let thinkingEffort = 'high'; // Effort level for extended thinking: 'low', 'medium', or 'high'
        let enableLatexRendering = false; // Whether to render LaTeX (loads KaTeX on-demand)
        let enableMarkdownRendering = false; // Whether to render Markdown (loads marked.js on-demand)
        let userIdentifier = 'Human'; // Customizable identifier for the user in multi-model conversations
        let availableModels = [];
        let filteredModels = [];
        let currentAbortControllers = [];
        let conversationHistory = []; // Array to store saved conversations
        let renderTimer = null; // Timer for debouncing render calls during streaming
        let thinkingCollapseState = {}; // View state for thinking section collapse (keyed by message timestamp or index)

        // Helper: Expand selectedModelEntries to flat array of indices for iteration
        function expandModelEntries() {
            const result = [];
            for (const entry of selectedModelEntries) {
                for (let i = 0; i < entry.count; i++) {
                    result.push(entry.modelIndex);
                }
            }
            return result;
        }

        // Helper: Get total number of model instances
        function getTotalModelInstances() {
            return selectedModelEntries.reduce((sum, e) => sum + e.count, 0);
        }

        // Helper: Get instance count for a specific model index
        function getInstanceCount(modelIndex) {
            const entry = selectedModelEntries.find(e => e.modelIndex === modelIndex);
            return entry ? entry.count : 0;
        }

        // Helper: Set instance count for a specific model index
        function setInstanceCount(modelIndex, count) {
            const existing = selectedModelEntries.find(e => e.modelIndex === modelIndex);
            if (count <= 0) {
                selectedModelEntries = selectedModelEntries.filter(e => e.modelIndex !== modelIndex);
            } else if (existing) {
                existing.count = count;
            } else {
                selectedModelEntries.push({ modelIndex, count });
            }
        }

        // Helper: Check if a model is selected
        function isModelSelected(modelIndex) {
            return selectedModelEntries.some(e => e.modelIndex === modelIndex);
        }

        // Helper: Migrate old format [0,0,1,1] to new format [{modelIndex: 0, count: 2}, ...]
        function migrateOldSelectedIndices(oldIndices) {
            const counts = {};
            const order = [];
            for (const idx of oldIndices) {
                if (!(idx in counts)) {
                    counts[idx] = 0;
                    order.push(idx);
                }
                counts[idx]++;
            }
            return order.map(modelIndex => ({ modelIndex, count: counts[modelIndex] }));
        }

        // Helper: Check if an assistant message has content
        function hasMessageContent(msg) {
            return msg.content || msg.thinking || (msg.images && msg.images.length > 0);
        }

        // Helper: Remove empty assistant messages from conversation
        function removeEmptyAssistantMessages() {
            currentConversation = currentConversation.filter(msg =>
                msg.role !== 'assistant' || hasMessageContent(msg)
            );
        }

        // Background audio to prevent iOS from pausing when screen is off
        let audioContext = null;
        let silentAudioNode = null;

        // Initialize
        async function init() {
            await loadFromStorage();
            // Load rendering libraries if previously enabled
            if (enableLatexRendering) await loadKaTeX();
            if (enableMarkdownRendering) await loadMarked();
            setupEventListeners();
            updateModelSelect();
            updateModelsList();
            updateApiKeysList();
            updatePromptsList();
            updateUserIdentifierInput();
            renderConversation();
            renderHistory();
        }

        // IndexedDB wrapper for storage
        let db = null;

        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('ApiChatDB', 1);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings');
                    }
                };
            });
        }

        async function saveData(key, value) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['settings'], 'readwrite');
                const store = transaction.objectStore('settings');
                const request = store.put(value, key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function loadData(key, defaultValue = null) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['settings'], 'readonly');
                const store = transaction.objectStore('settings');
                const request = store.get(key);
                request.onsuccess = () => {
                    resolve(request.result !== undefined ? request.result : defaultValue);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function loadFromStorage() {
            try {
                await initDB();

                models = await loadData('models', []);
                apiKeys = await loadData('apiKeys', []);
                systemPrompts = await loadData('systemPrompts', []);
                activePromptId = await loadData('activePromptId', null);
                currentConversation = await loadData('currentConversation', []);

                // Load model entries (new format) or migrate from old format
                let storedEntries = await loadData('selectedModelEntries', null);
                if (storedEntries === null) {
                    // Try loading old format and migrate
                    const oldIndices = await loadData('selectedModelIndices', []);
                    if (oldIndices.length > 0) {
                        selectedModelEntries = migrateOldSelectedIndices(oldIndices);
                    } else {
                        selectedModelEntries = [];
                    }
                } else {
                    selectedModelEntries = storedEntries;
                }

                // Sanitize entries to prevent stale indices
                selectedModelEntries = selectedModelEntries
                    .filter(e => e && typeof e.modelIndex === 'number' &&
                                 e.modelIndex >= 0 && e.modelIndex < models.length &&
                                 e.count > 0);

                multiModelMode = await loadData('multiModelMode', 'parallel');
                rotationIndex = await loadData('rotationIndex', 0);
                iterationCount = await loadData('iterationCount', 1);
                messageHistoryLimit = await loadData('messageHistoryLimit', 0);
                includeFilesInHistory = await loadData('includeFilesInHistory', false);
                responseDelay = await loadData('responseDelay', 1000);
                enableModelIdentity = await loadData('enableModelIdentity', true);
                enableBackgroundAudio = await loadData('enableBackgroundAudio', false);
                enableExtendedThinking = await loadData('enableExtendedThinking', false);
                enableLatexRendering = await loadData('enableLatexRendering', false);
                enableMarkdownRendering = await loadData('enableMarkdownRendering', false);
                thinkingEffort = await loadData('thinkingEffort', 'high');
                userIdentifier = await loadData('userIdentifier', 'Human');
                conversationHistory = await loadData('conversationHistory', []);
            } catch (e) {
                console.error('Error loading from IndexedDB:', e);
            }
        }

        async function saveToStorage() {
            try {
                await Promise.all([
                    saveData('models', models),
                    saveData('apiKeys', apiKeys),
                    saveData('systemPrompts', systemPrompts),
                    saveData('activePromptId', activePromptId),
                    saveData('currentConversation', currentConversation),
                    saveData('selectedModelEntries', selectedModelEntries),
                    saveData('multiModelMode', multiModelMode),
                    saveData('rotationIndex', rotationIndex),
                    saveData('iterationCount', iterationCount),
                    saveData('messageHistoryLimit', messageHistoryLimit),
                    saveData('includeFilesInHistory', includeFilesInHistory),
                    saveData('responseDelay', responseDelay),
                    saveData('enableModelIdentity', enableModelIdentity),
                    saveData('enableBackgroundAudio', enableBackgroundAudio),
                    saveData('enableExtendedThinking', enableExtendedThinking),
                    saveData('enableLatexRendering', enableLatexRendering),
                    saveData('enableMarkdownRendering', enableMarkdownRendering),
                    saveData('thinkingEffort', thinkingEffort),
                    saveData('userIdentifier', userIdentifier),
                    saveData('conversationHistory', conversationHistory)
                ]);
            } catch (e) {
                console.error('Error saving to IndexedDB:', e);
            }
        }

        function startBackgroundAudio() {
            if (!enableBackgroundAudio) return;

            try {
                if (!audioContext) {
                    // Create audio context
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Resume context if suspended (needed for iOS)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                if (!silentAudioNode) {
                    // Create a very quiet oscillator (barely audible)
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    // Set to extremely low volume (essentially silent)
                    gainNode.gain.value = 0.0001;

                    // Connect nodes
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    // Start oscillator
                    oscillator.start();

                    silentAudioNode = { oscillator, gainNode };
                }
            } catch (e) {
                console.error('Error starting background audio:', e);
            }
        }

        function stopBackgroundAudio() {
            try {
                if (silentAudioNode) {
                    silentAudioNode.oscillator.stop();
                    silentAudioNode.oscillator.disconnect();
                    silentAudioNode.gainNode.disconnect();
                    silentAudioNode = null;
                }

                if (audioContext && audioContext.state !== 'closed') {
                    audioContext.suspend();
                }
            } catch (e) {
                console.error('Error stopping background audio:', e);
            }
        }

        function setupEventListeners() {
            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.dataset.tab;
                    switchTab(tabName);
                });
            });

            // Send message
            document.getElementById('send-btn').addEventListener('click', sendMessage);

            // Stop generation
            document.getElementById('stop-btn').addEventListener('click', stopGeneration);

            // Prefill button
            document.getElementById('prefill-btn').addEventListener('click', enterPrefillMode);

            // File upload
            document.getElementById('file-input').addEventListener('change', handleFileUpload);

            // Model picker button
            document.getElementById('model-picker-btn').addEventListener('click', openModelPicker);

            // Model picker popup - click outside to close
            document.getElementById('model-picker-popup').addEventListener('click', (e) => {
                if (e.target.id === 'model-picker-popup') {
                    closeModelPicker();
                }
            });

            // Model mode radio buttons
            document.querySelectorAll('input[name="model-mode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const newMode = e.target.value;
                    multiModelMode = newMode;

                    // Reset rotation index when leaving rotating mode
                    if (newMode !== 'rotating') {
                        rotationIndex = 0;
                    }

                    updateUIForMode();
                    updateModelPickerButton();
                    saveToStorage();
                });
            });

            // Iteration count input
            const iterationInput = document.getElementById('iteration-count');
            if (iterationInput) {
                iterationInput.addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (value >= 1 && value <= 100) {
                        iterationCount = value;
                        saveToStorage();
                    } else {
                        e.target.value = iterationCount;
                    }
                });
            }

            // Response delay input
            const delayInput = document.getElementById('response-delay');
            if (delayInput) {
                delayInput.addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (value >= 0 && value <= 10000) {
                        responseDelay = value;
                        saveToStorage();
                    } else {
                        e.target.value = responseDelay;
                    }
                });
            }

            // Message history limit input
            const historyLimitInput = document.getElementById('history-limit');
            if (historyLimitInput) {
                historyLimitInput.addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (value >= 0 && value <= 1000) {
                        messageHistoryLimit = value;
                        saveToStorage();
                    } else {
                        e.target.value = messageHistoryLimit;
                    }
                });
            }

            // Include files checkbox
            const includeFilesCheckbox = document.getElementById('include-files-checkbox');
            if (includeFilesCheckbox) {
                includeFilesCheckbox.addEventListener('change', (e) => {
                    includeFilesInHistory = e.target.checked;
                    saveToStorage();
                });
            }

            // Enable model identity checkbox
            const enableIdentityCheckbox = document.getElementById('enable-identity-checkbox');
            if (enableIdentityCheckbox) {
                enableIdentityCheckbox.addEventListener('change', (e) => {
                    enableModelIdentity = e.target.checked;
                    saveToStorage();
                });
            }

            const backgroundAudioCheckbox = document.getElementById('background-audio-checkbox');
            if (backgroundAudioCheckbox) {
                backgroundAudioCheckbox.addEventListener('change', (e) => {
                    enableBackgroundAudio = e.target.checked;
                    saveToStorage();
                    // Stop audio if disabled while running
                    if (!enableBackgroundAudio) {
                        stopBackgroundAudio();
                    }
                });
            }

            // Extended thinking checkbox
            const extendedThinkingCheckbox = document.getElementById('extended-thinking-checkbox');
            if (extendedThinkingCheckbox) {
                extendedThinkingCheckbox.addEventListener('change', (e) => {
                    enableExtendedThinking = e.target.checked;
                    saveToStorage();
                });
            }

            // Thinking effort selector
            const thinkingEffortSelect = document.getElementById('thinking-effort');
            if (thinkingEffortSelect) {
                thinkingEffortSelect.addEventListener('change', (e) => {
                    thinkingEffort = e.target.value;
                    saveToStorage();
                });
            }

            // LaTeX rendering checkbox
            const latexRenderingCheckbox = document.getElementById('latex-rendering-checkbox');
            if (latexRenderingCheckbox) {
                latexRenderingCheckbox.addEventListener('change', async (e) => {
                    enableLatexRendering = e.target.checked;
                    if (enableLatexRendering) {
                        await loadKaTeX();
                    }
                    saveToStorage();
                    renderConversation();
                });
            }

            // Markdown rendering checkbox
            const markdownRenderingCheckbox = document.getElementById('markdown-rendering-checkbox');
            if (markdownRenderingCheckbox) {
                markdownRenderingCheckbox.addEventListener('change', async (e) => {
                    enableMarkdownRendering = e.target.checked;
                    if (enableMarkdownRendering) {
                        await loadMarked();
                    }
                    saveToStorage();
                    renderConversation();
                });
            }

            // Autonomous button
            document.getElementById('auto-btn').addEventListener('click', toggleAutonomous);

            // Resume audio context when returning to the tab/app (iOS resurrection)
            document.addEventListener('visibilitychange', async () => {
                if (!document.hidden && enableBackgroundAudio && audioContext && audioContext.state === 'interrupted') {
                    console.log('Resuming interrupted audio context...');
                    try {
                        await audioContext.resume();
                    } catch (e) {
                        console.error('Error resuming audio context:', e);
                    }
                }
            });

            // Handle mobile keyboard show/hide to fix viewport issues
            // When keyboard closes, scroll chat to bottom and fix layout
            let lastHeight = window.innerHeight;

            window.addEventListener('resize', () => {
                const currentHeight = window.innerHeight;

                // Keyboard closed (viewport got taller)
                if (currentHeight > lastHeight) {
                    // Scroll chat to bottom
                    const chatMessages = document.getElementById('chat-messages');
                    if (chatMessages) {
                        setTimeout(() => {
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }, 100);
                    }

                    // Force layout recalculation
                    document.body.style.height = currentHeight + 'px';
                    setTimeout(() => {
                        document.body.style.height = '100dvh';
                    }, 200);
                }

                lastHeight = currentHeight;
            });

            // Handle Visual Viewport API for better mobile support
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => {
                    const viewport = window.visualViewport;

                    // When keyboard is hidden (viewport height increases)
                    if (viewport.height > lastHeight) {
                        const chatMessages = document.getElementById('chat-messages');
                        if (chatMessages) {
                            setTimeout(() => {
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }, 100);
                        }
                    }

                    lastHeight = viewport.height;
                });
            }

            // Also handle when input loses focus
            const messageInput = document.getElementById('message-input');
            messageInput.addEventListener('blur', () => {
                setTimeout(() => {
                    // Scroll to bottom when keyboard closes
                    window.scrollTo(0, 0);
                    const chatMessages = document.getElementById('chat-messages');
                    if (chatMessages) {
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }, 300);
            });

            // Pre-populate OpenRouter config
            updateModelConfigTemplate();
        }

        function updateModelConfigTemplate() {
            const configTextarea = document.getElementById('new-model-config');
            const openrouterKeys = apiKeys.filter(k => k.provider === 'openrouter');
            const apiKeyRef = openrouterKeys.length > 0
                ? `"api_key_id": "${openrouterKeys[0].id}"`
                : `"api_key": "your-openrouter-api-key-here"`;

            configTextarea.value = `"endpoint": "https://openrouter.ai/api/v1/responses",
"model_id": "anthropic/claude-3.5-sonnet",
${apiKeyRef},
"system_prompt": "",
"max_output_tokens": null,
"temperature": 1.0,
"top_p": null,
"top_k": null,
"frequency_penalty": null,
"presence_penalty": null,
"seed": null,
"stop": null,
"tools": null,
"tool_choice": null,
"parallel_tool_calls": null,
"reasoning": null,
"text": null,
"user": null,
"session_id": null,
"store": null,
"metadata": null,
"provider": null,
"plugins": null,
"timeout": 120000`;
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');

            if (tabName === 'settings') {
                updateModelsList();
                updateApiKeysList();
                updatePromptsList();
                updateModelConfigTemplate();
            }
        }

        function updateModelSelect() {
            updateModelPickerButton();
        }

        function updateModelPickerButton() {
            const btn = document.getElementById('model-picker-btn');
            const totalInstances = getTotalModelInstances();
            if (totalInstances === 0) {
                btn.textContent = 'Select Models';
            } else if (totalInstances === 1 && selectedModelEntries.length === 1) {
                const name = models[selectedModelEntries[0].modelIndex]?.name;
                btn.textContent = name ? stripCompanyPrefix(name) : 'Select Models';
            } else {
                btn.textContent = `${totalInstances} Models (${multiModelMode})`;
            }
        }

        function openModelPicker() {
            const popup = document.getElementById('model-picker-popup');
            const checkboxesContainer = document.getElementById('model-checkboxes');

            // Populate system prompt selector
            const promptSelect = document.getElementById('picker-prompt-select');
            promptSelect.innerHTML = '<option value="">None (no system prompt)</option>';
            systemPrompts.forEach(prompt => {
                const option = document.createElement('option');
                option.value = prompt.id;
                option.textContent = prompt.name;
                if (prompt.id === activePromptId) {
                    option.selected = true;
                }
                promptSelect.appendChild(option);
            });
            promptSelect.onchange = (e) => {
                activePromptId = e.target.value || null;
                saveToStorage();
            };

            checkboxesContainer.innerHTML = '';

            if (models.length === 0) {
                checkboxesContainer.innerHTML = '<p style="color: #888;">No models configured. Add models in Settings.</p>';
            } else {
                models.forEach((model, index) => {
                    const wrapper = document.createElement('div');
                    wrapper.style.cssText = 'display: flex; align-items: center; gap: 8px; margin-bottom: 5px;';
                    wrapper.dataset.modelIndex = index;

                    const label = document.createElement('label');
                    label.style.cssText = 'flex: 1; margin-bottom: 0;';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = index;

                    // Get instance count from new structure
                    const instanceCount = getInstanceCount(index);
                    checkbox.checked = instanceCount > 0;

                    checkbox.addEventListener('change', (e) => {
                        const countInput = wrapper.querySelector('input[type="number"]');
                        if (e.target.checked) {
                            const count = parseInt(countInput.value) || 1;
                            setInstanceCount(index, count);
                        } else {
                            setInstanceCount(index, 0);
                            countInput.value = 1;
                        }
                        saveToStorage();
                        updateModelPickerButton();
                    });

                    label.appendChild(checkbox);

                    // Create a div for model info
                    const modelInfo = document.createElement('div');
                    modelInfo.className = 'model-info';

                    const modelName = document.createElement('div');
                    modelName.className = 'model-name';
                    modelName.textContent = stripCompanyPrefix(model.name);
                    modelInfo.appendChild(modelName);

                    // Show active system prompt (global overrides per-model)
                    let promptText = null;
                    if (activePromptId) {
                        const prompt = systemPrompts.find(p => p.id === activePromptId);
                        if (prompt) {
                            promptText = prompt.content;
                        }
                    } else if (model.system_prompt && model.system_prompt.trim()) {
                        promptText = model.system_prompt;
                    }

                    if (promptText) {
                        const promptPreview = document.createElement('div');
                        promptPreview.className = 'system-prompt-preview';
                        const previewText = promptText.length > 60
                            ? promptText.substring(0, 60) + '...'
                            : promptText;
                        promptPreview.textContent = `System: ${previewText}`;
                        modelInfo.appendChild(promptPreview);
                    }

                    label.appendChild(modelInfo);

                    // Add instance count input
                    const countInput = document.createElement('input');
                    countInput.type = 'number';
                    countInput.min = '1';
                    countInput.max = '10';
                    countInput.value = instanceCount > 0 ? instanceCount : 1;
                    countInput.style.cssText = 'width: 50px; padding: 4px; background: #3a3a3a; border: 1px solid #4a4a4a; color: #e0e0e0; border-radius: 4px; text-align: center;';
                    countInput.title = 'Number of instances';

                    countInput.addEventListener('change', (e) => {
                        if (!checkbox.checked) return;

                        const newCount = Math.max(1, Math.min(10, parseInt(e.target.value) || 1));
                        e.target.value = newCount;
                        setInstanceCount(index, newCount);
                        saveToStorage();
                        updateModelPickerButton();
                    });

                    // Assemble the wrapper
                    wrapper.appendChild(label);
                    wrapper.appendChild(countInput);
                    checkboxesContainer.appendChild(wrapper);
                });
            }

            // Set the current mode
            document.querySelectorAll('input[name="model-mode"]').forEach(radio => {
                radio.checked = (radio.value === multiModelMode);
            });

            // Set the iteration count
            const iterationInput = document.getElementById('iteration-count');
            if (iterationInput) {
                iterationInput.value = iterationCount;
            }

            // Set the response delay
            const delayInput = document.getElementById('response-delay');
            if (delayInput) {
                delayInput.value = responseDelay;
            }

            // Set the history limit
            const historyLimitInput = document.getElementById('history-limit');
            if (historyLimitInput) {
                historyLimitInput.value = messageHistoryLimit;
            }

            // Set the include files checkbox
            const includeFilesCheckbox = document.getElementById('include-files-checkbox');
            if (includeFilesCheckbox) {
                includeFilesCheckbox.checked = includeFilesInHistory;
            }

            // Set the enable identity checkbox
            const enableIdentityCheckbox = document.getElementById('enable-identity-checkbox');
            if (enableIdentityCheckbox) {
                enableIdentityCheckbox.checked = enableModelIdentity;
            }

            // Set the background audio checkbox
            const backgroundAudioCheckbox = document.getElementById('background-audio-checkbox');
            if (backgroundAudioCheckbox) {
                backgroundAudioCheckbox.checked = enableBackgroundAudio;
            }

            // Set the extended thinking checkbox
            const extendedThinkingCheckbox = document.getElementById('extended-thinking-checkbox');
            if (extendedThinkingCheckbox) {
                extendedThinkingCheckbox.checked = enableExtendedThinking;
            }

            // Set the thinking effort selector
            const thinkingEffortSelect = document.getElementById('thinking-effort');
            if (thinkingEffortSelect) {
                thinkingEffortSelect.value = thinkingEffort;
            }

            // Set the LaTeX rendering checkbox
            const latexRenderingCheckbox = document.getElementById('latex-rendering-checkbox');
            if (latexRenderingCheckbox) {
                latexRenderingCheckbox.checked = enableLatexRendering;
            }

            // Set the Markdown rendering checkbox
            const markdownRenderingCheckbox = document.getElementById('markdown-rendering-checkbox');
            if (markdownRenderingCheckbox) {
                markdownRenderingCheckbox.checked = enableMarkdownRendering;
            }

            popup.style.display = 'flex';
        }

        function closeModelPicker() {
            document.getElementById('model-picker-popup').style.display = 'none';
            updateUIForMode();
        }

        function updateUIForMode() {
            const autoBtn = document.getElementById('auto-btn');
            const sendBtn = document.getElementById('send-btn');
            const messageInput = document.getElementById('message-input');

            if (multiModelMode === 'autonomous') {
                autoBtn.style.display = 'block';
                sendBtn.style.display = 'none';
                messageInput.disabled = true;
                messageInput.placeholder = 'Autonomous mode - models will converse automatically';
                updateModelPickerButton();
            } else {
                autoBtn.style.display = 'none';
                sendBtn.style.display = 'block';
                messageInput.disabled = false;
                messageInput.placeholder = 'Type a message... (Click Send button to send)';
            }
        }

        async function toggleAutonomous() {
            const autoBtn = document.getElementById('auto-btn');

            if (isAutonomousRunning) {
                isAutonomousRunning = false;
                userStoppedGeneration = true;

                // Abort all ongoing requests to stop immediately
                currentAbortControllers.forEach(controller => {
                    try {
                        controller.abort();
                    } catch (e) {
                        console.error('Error aborting request:', e);
                    }
                });
                currentAbortControllers = [];

                autoBtn.textContent = 'Start Auto';
                autoBtn.style.background = '#4a9eff';
                return;
            }

            if (getTotalModelInstances() < 2) {
                alert('Please select at least 2 model instances for autonomous mode');
                return;
            }

            // If conversation is empty, add a starter message for autonomous mode
            if (currentConversation.length === 0) {
                const starterMessage = {
                    role: 'user',
                    content: 'Begin your conversation.',
                    timestamp: new Date().toISOString()
                };
                currentConversation.push(starterMessage);
                saveToStorage();
                renderConversation();
            }

            isAutonomousRunning = true;
            userStoppedGeneration = false;  // Reset stop flag when starting
            autonomousRounds = 0;
            autoBtn.textContent = 'Stop Auto';
            autoBtn.style.background = '#ff4a4a';

            // Run for iterationCount rounds per model (or until stopped manually)
            // Total rounds = iterationCount * number of model instances
            const totalInstances = getTotalModelInstances();
            while (isAutonomousRunning && autonomousRounds < (iterationCount * totalInstances)) {
                try {
                    await handleAutonomousRound();
                    autonomousRounds++;

                    // Delay between rounds (configurable)
                    if (responseDelay > 0 && autonomousRounds < (iterationCount * totalInstances)) {
                        await new Promise(resolve => setTimeout(resolve, responseDelay));
                    }
                } catch (error) {
                    console.error('Autonomous error:', error);

                    // Remove any empty assistant messages that were added before the error
                    removeEmptyAssistantMessages();

                    isAutonomousRunning = false;
                    autoBtn.textContent = 'Start Auto';
                    autoBtn.style.background = '#4a9eff';
                    saveToStorage();
                    renderConversation();
                    alert('Error in autonomous mode: ' + error.message);
                }
            }

            // Final cleanup: Remove any empty assistant messages
            removeEmptyAssistantMessages();

            // Reset button when done (either completed iterations or stopped manually)
            isAutonomousRunning = false;
            autoBtn.textContent = 'Start Auto';
            autoBtn.style.background = '#4a9eff';
            saveToStorage();
            renderConversation();
        }

        function updatePromptsList() {
            const list = document.getElementById('prompts-list');
            list.innerHTML = '';

            if (systemPrompts.length === 0) {
                list.innerHTML = '<p style="color: #888;">No saved prompts yet.</p>';
                return;
            }

            systemPrompts.forEach(prompt => {
                const div = document.createElement('div');
                div.className = 'prompt-item';
                div.innerHTML = `
                    <h4>${escapeHtml(prompt.name)}</h4>
                    <div style="white-space: pre-wrap; font-size: 13px; color: #aaa;">${escapeHtml(prompt.content.substring(0, 200))}${prompt.content.length > 200 ? '...' : ''}</div>
                    <div class="prompt-actions">
                        <button onclick="editPrompt('${prompt.id}')">Edit</button>
                        <button onclick="deletePrompt('${prompt.id}')">Delete</button>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function addSystemPrompt() {
            const name = document.getElementById('new-prompt-name').value.trim();
            const content = document.getElementById('new-prompt-content').value.trim();

            if (!name || !content) {
                alert('Please enter both name and content');
                return;
            }

            if (editingPromptId !== null) {
                // Update existing prompt
                const promptIndex = systemPrompts.findIndex(p => p.id === editingPromptId);
                if (promptIndex !== -1) {
                    systemPrompts[promptIndex].name = name;
                    systemPrompts[promptIndex].content = content;
                }
                editingPromptId = null;
                const addBtn = document.querySelector('#settings-tab button[onclick="addSystemPrompt()"]');
                if (addBtn) addBtn.textContent = 'Add Prompt';
            } else {
                // Add new prompt
                const prompt = {
                    id: Date.now().toString(),
                    name,
                    content
                };
                systemPrompts.push(prompt);
            }

            saveToStorage();
            updatePromptsList();

            document.getElementById('new-prompt-name').value = '';
            document.getElementById('new-prompt-content').value = '';
        }

        function editPrompt(id) {
            const prompt = systemPrompts.find(p => p.id === id);
            if (!prompt) return;

            document.getElementById('new-prompt-name').value = prompt.name;
            document.getElementById('new-prompt-content').value = prompt.content;

            // Track which prompt is being edited (don't delete yet)
            editingPromptId = id;

            // Update button text to indicate editing mode
            const addBtn = document.querySelector('#settings-tab button[onclick="addSystemPrompt()"]');
            if (addBtn) addBtn.textContent = 'Save Prompt';

            // Scroll to the form
            document.querySelector('#new-prompt-name').scrollIntoView({ behavior: 'smooth' });
        }

        function cancelPromptEdit() {
            editingPromptId = null;
            document.getElementById('new-prompt-name').value = '';
            document.getElementById('new-prompt-content').value = '';
            const addBtn = document.querySelector('#settings-tab button[onclick="addSystemPrompt()"]');
            if (addBtn) addBtn.textContent = 'Add Prompt';
        }

        function deletePrompt(id) {
            if (!confirm('Delete this prompt?')) return;
            systemPrompts = systemPrompts.filter(p => p.id !== id);
            if (activePromptId === id) {
                activePromptId = null;
            }
            saveToStorage();
            updatePromptsList();
        }

        function saveUserIdentifier() {
            const input = document.getElementById('user-identifier-input');
            const value = input.value.trim();

            if (!value) {
                alert('Please enter an identifier');
                return;
            }

            userIdentifier = value;
            saveToStorage();
            alert(`User identifier updated to: ${value}`);
        }

        function updateUserIdentifierInput() {
            const input = document.getElementById('user-identifier-input');
            if (input) {
                input.value = userIdentifier;
            }
        }

        function addApiKey() {
            const name = document.getElementById('new-key-name').value.trim();
            const value = document.getElementById('new-key-value').value.trim();

            if (!name || !value) {
                alert('Please fill in all fields');
                return;
            }

            const apiKey = {
                id: Date.now().toString(),
                name,
                provider: 'openrouter',  // Always OpenRouter
                value
            };

            apiKeys.push(apiKey);
            saveToStorage();
            updateApiKeysList();
            updateModelConfigTemplate();  // Update model template with new key

            // Clear form
            document.getElementById('new-key-name').value = '';
            document.getElementById('new-key-value').value = '';

            alert('API key added successfully!');
        }

        function deleteApiKey(id) {
            if (!confirm('Delete this API key?')) return;
            apiKeys = apiKeys.filter(k => k.id !== id);
            saveToStorage();
            updateApiKeysList();
            updateModelConfigTemplate();  // Update template after deleting key
        }

        function updateApiKeysList() {
            const list = document.getElementById('api-keys-list');
            list.innerHTML = '';

            if (apiKeys.length === 0) {
                list.innerHTML = '<p style="color: #888;">No API keys saved yet.</p>';
                return;
            }

            apiKeys.forEach(key => {
                const div = document.createElement('div');
                div.className = 'prompt-item';
                div.innerHTML = `
                    <h4>${escapeHtml(key.name)}</h4>
                    <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
                        ID: ${escapeHtml(key.id)}
                    </div>
                    <div style="font-size: 13px; color: #aaa; margin-bottom: 4px;">
                        <strong>Provider:</strong> ${escapeHtml(key.provider)}<br>
                        <strong>Key:</strong> ${escapeHtml(key.value.substring(0, 10))}...${escapeHtml(key.value.substring(key.value.length - 4))}
                    </div>
                    <div class="prompt-actions">
                        <button onclick="deleteApiKey('${key.id}')">Delete</button>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function addModel() {
            const name = document.getElementById('new-model-name').value.trim();
            const configText = document.getElementById('new-model-config').value.trim();

            if (!name) {
                alert('Please enter a model name');
                return;
            }

            if (!configText) {
                alert('Please select a template or enter model configuration');
                return;
            }

            try {
                // Wrap in {} if not already wrapped
                const jsonText = configText.trim().startsWith('{')
                    ? configText
                    : `{${configText}}`;

                const config = JSON.parse(jsonText);

                // Validate required fields
                if (!config.endpoint || !config.model_id || (!config.api_key && !config.api_key_id)) {
                    alert('Configuration must include: endpoint, model_id, and api_key (or api_key_id)');
                    return;
                }

                const model = {
                    name,
                    ...config
                };

                if (editingModelIndex !== null) {
                    // Update existing model
                    models[editingModelIndex] = model;
                    editingModelIndex = null;
                    const addBtn = document.querySelector('#settings-tab button[onclick="addModel()"]');
                    if (addBtn) addBtn.textContent = 'Add Model';
                    alert('Model updated successfully!');
                } else {
                    // Add new model
                    models.push(model);
                    alert('Model added successfully!');
                }

                saveToStorage();
                updateModelSelect();
                updateModelsList();

                // Clear form and reload template
                document.getElementById('new-model-name').value = '';
                updateModelConfigTemplate();
            } catch (e) {
                alert('Invalid JSON configuration: ' + e.message);
            }
        }

        function editModel(index) {
            const model = models[index];
            const { name, ...config } = model;

            document.getElementById('new-model-name').value = name;

            // Convert config back to formatted JSON without outer braces, normalized indentation
            const configJson = JSON.stringify(config, null, 2);
            const withoutBraces = configJson
                .substring(1, configJson.length - 1)
                .trim()
                .split('\n')
                .map(line => line.replace(/^  /, ''))  // Remove leading 2-space indent
                .join('\n');
            document.getElementById('new-model-config').value = withoutBraces;

            // Track which model is being edited (don't delete yet)
            editingModelIndex = index;

            // Update button text to indicate editing mode
            const addBtn = document.querySelector('#settings-tab button[onclick="addModel()"]');
            if (addBtn) addBtn.textContent = 'Save Model';

            // Scroll to the form
            document.querySelector('#new-model-name').scrollIntoView({ behavior: 'smooth' });
        }

        function cancelModelEdit() {
            editingModelIndex = null;
            document.getElementById('new-model-name').value = '';
            updateModelConfigTemplate();
            const addBtn = document.querySelector('#settings-tab button[onclick="addModel()"]');
            if (addBtn) addBtn.textContent = 'Add Model';
        }

        function deleteModel(index) {
            if (!confirm('Delete this model?')) return;
            models.splice(index, 1);

            // Update selectedModelEntries: remove this index and adjust higher indices
            selectedModelEntries = selectedModelEntries
                .filter(e => e.modelIndex !== index)
                .map(e => e.modelIndex > index ? { ...e, modelIndex: e.modelIndex - 1 } : e);

            saveToStorage();
            updateModelSelect();
            updateModelsList();
        }

        function updateModelsList() {
            const list = document.getElementById('models-list');
            list.innerHTML = '';

            if (models.length === 0) {
                list.innerHTML = '<p style="color: #888;">No models configured yet.</p>';
                return;
            }

            models.forEach((model, index) => {
                const div = document.createElement('div');
                div.className = 'prompt-item';

                // Create config object without the name field for display
                // Strip outer braces and normalize indentation to match the edit format
                const { name, ...config } = model;
                const configJson = JSON.stringify(config, null, 2);
                const configWithoutBraces = configJson
                    .substring(1, configJson.length - 1)
                    .trim()
                    .split('\n')
                    .map(line => line.replace(/^  /, ''))  // Remove leading 2-space indent
                    .join('\n');

                div.innerHTML = `
                    <h4>${escapeHtml(model.name)}</h4>
                    <div style="font-size: 13px; color: #aaa; margin-bottom: 8px;">
                        <strong>Model ID:</strong> ${escapeHtml(model.model_id)}
                    </div>
                    <details style="margin-bottom: 8px;">
                        <summary style="cursor: pointer; color: #4a9eff; font-size: 13px;">View Configuration</summary>
                        <pre style="background: #1a1a1a; padding: 8px; border-radius: 4px; overflow-x: auto; font-size: 12px; margin-top: 8px;">${escapeHtml(configWithoutBraces)}</pre>
                    </details>
                    <div class="prompt-actions">
                        <button onclick="editModel(${index})">Edit</button>
                        <button onclick="deleteModel(${index})">Delete</button>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        async function fetchOpenRouterModels() {
            const browser = document.getElementById('models-browser');
            browser.style.display = 'block';
            browser.innerHTML = '<p style="color: #888;">Loading models from OpenRouter...</p>';

            try {
                const response = await fetch('https://openrouter.ai/api/v1/models');
                if (!response.ok) {
                    throw new Error(`Failed to fetch models: ${response.status}`);
                }

                const data = await response.json();
                availableModels = data.data || [];
                filteredModels = [...availableModels];

                sortAndDisplayModels();
            } catch (error) {
                browser.innerHTML = `<p style="color: #ff6b6b;">Error loading models: ${escapeHtml(error.message)}</p>`;
                console.error('Error fetching models:', error);
            }
        }

        function filterModels() {
            const searchTerm = document.getElementById('model-search').value.toLowerCase();

            if (!searchTerm) {
                filteredModels = [...availableModels];
            } else {
                filteredModels = availableModels.filter(model => {
                    const searchText = `${model.id} ${model.name || ''} ${model.description || ''}`.toLowerCase();
                    return searchText.includes(searchTerm);
                });
            }

            sortAndDisplayModels();
        }

        function sortAndDisplayModels() {
            const sortBy = document.getElementById('model-sort').value;

            // Sort
            filteredModels.sort((a, b) => {
                if (sortBy === 'date') {
                    const dateA = new Date(a.created || 0);
                    const dateB = new Date(b.created || 0);
                    return dateB - dateA; // Newest first
                } else if (sortBy === 'name') {
                    return (a.name || a.id).localeCompare(b.name || b.id);
                } else if (sortBy === 'context') {
                    return (b.context_length || 0) - (a.context_length || 0); // Largest first
                }
                return 0;
            });

            displayModels();
        }

        function displayModels() {
            const browser = document.getElementById('models-browser');

            if (filteredModels.length === 0) {
                browser.innerHTML = '<p style="color: #888;">No models found matching your search.</p>';
                return;
            }

            let html = `<div style="font-size: 13px; color: #888; margin-bottom: 12px;">Found ${filteredModels.length} models. Click to select.</div>`;

            filteredModels.forEach(model => {
                const pricing = model.pricing || {};
                const promptPrice = pricing.prompt ? `$${(parseFloat(pricing.prompt) * 1000000).toFixed(2)}/M` : 'N/A';
                const completionPrice = pricing.completion ? `$${(parseFloat(pricing.completion) * 1000000).toFixed(2)}/M` : 'N/A';
                const contextLength = model.context_length ? `${(model.context_length / 1000).toFixed(0)}K` : 'N/A';
                const created = model.created ? new Date(model.created * 1000).toLocaleDateString() : 'Unknown';

                const displayName = stripCompanyPrefix(model.name || model.id);
                html += `
                    <div style="background: #2a2a2a; padding: 12px; border-radius: 6px; margin-bottom: 8px; cursor: pointer; border: 2px solid transparent;"
                         onclick="selectModel('${escapeHtml(model.id)}', '${escapeHtml(displayName)}')"
                         onmouseover="this.style.borderColor='#4a9eff'"
                         onmouseout="this.style.borderColor='transparent'">
                        <div style="font-weight: 600; color: #e0e0e0; margin-bottom: 4px;">${escapeHtml(displayName)}</div>
                        <div style="font-size: 12px; color: #888; font-family: monospace; margin-bottom: 6px;">${escapeHtml(model.id)}</div>
                        <div style="font-size: 12px; color: #aaa; margin-bottom: 6px;">${escapeHtml(model.description || 'No description')}</div>
                        <div style="font-size: 11px; color: #666; display: flex; gap: 12px;">
                            <span>Context: ${contextLength}</span>
                            <span>Prompt: ${promptPrice}</span>
                            <span>Completion: ${completionPrice}</span>
                            <span>Released: ${created}</span>
                        </div>
                    </div>
                `;
            });

            browser.innerHTML = html;
        }

        function selectModel(modelId, modelName) {
            // Populate the Add New Model form
            document.getElementById('new-model-name').value = modelName;

            // Get the current config template
            const configTextarea = document.getElementById('new-model-config');
            let currentConfig = configTextarea.value;

            // Replace the model_id in the template
            currentConfig = currentConfig.replace(
                /"model_id":\s*"[^"]*"/,
                `"model_id": "${modelId}"`
            );

            configTextarea.value = currentConfig;

            // Scroll to the Add New Model section
            document.querySelector('#new-model-name').scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Flash the textarea to show it was updated
            configTextarea.style.border = '2px solid #4a9eff';
            setTimeout(() => {
                configTextarea.style.border = '';
            }, 1000);
        }

        async function handleFileUpload(e) {
            const files = Array.from(e.target.files);

            for (const file of files) {
                const base64 = await fileToBase64(file);
                const fileObj = {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    base64: base64.split(',')[1] // Remove data URL prefix
                };

                // Extract text content from PDFs and text files
                const extractedContent = await extractFileContent(file);
                if (extractedContent !== null) {
                    fileObj.extractedText = extractedContent;
                }

                attachedFiles.push(fileObj);
            }

            renderAttachedFiles();
            e.target.value = ''; // Reset input
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Lazy-load PDF.js on first use
        let pdfjsLoaded = false;
        async function loadPdfJs() {
            if (pdfjsLoaded) return;
            if (typeof pdfjsLib !== 'undefined') {
                pdfjsLoaded = true;
                return;
            }

            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js';
                script.onload = () => {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
                    pdfjsLoaded = true;
                    resolve();
                };
                script.onerror = () => reject(new Error('Failed to load PDF.js'));
                document.head.appendChild(script);
            });
        }

        // Extract text content from a PDF file
        async function extractTextFromPDF(file) {
            try {
                await loadPdfJs();
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let fullText = '';

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();

                    // Preserve layout using Y-coordinates
                    let lastY = null;
                    let pageLines = [];
                    let currentLine = [];

                    for (const item of textContent.items) {
                        const text = item.str;
                        const y = item.transform[5];

                        if (lastY === null) {
                            lastY = y;
                        }

                        // New "line" when Y changes significantly
                        if (Math.abs(y - lastY) > 5) {
                            if (currentLine.length) {
                                pageLines.push(currentLine.join(' '));
                                currentLine = [];
                            }
                            lastY = y;
                        }

                        currentLine.push(text);
                    }
                    if (currentLine.length) {
                        pageLines.push(currentLine.join(' '));
                    }

                    fullText += `\n--- Page ${i} ---\n${pageLines.join('\n')}\n`;
                }

                return fullText.trim();
            } catch (error) {
                console.error('Error extracting PDF text:', error);
                return `[Error extracting text from PDF: ${error.message}]`;
            }
        }

        // Read text content from a text file
        async function readTextFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        // Extract content from a file based on its type
        async function extractFileContent(file) {
            const type = file.type.toLowerCase();
            const name = file.name.toLowerCase();

            // PDFs
            if (type === 'application/pdf' || name.endsWith('.pdf')) {
                return await extractTextFromPDF(file);
            }

            // Text files
            if (type.startsWith('text/') ||
                name.endsWith('.txt') ||
                name.endsWith('.md') ||
                name.endsWith('.json') ||
                name.endsWith('.csv') ||
                name.endsWith('.xml') ||
                name.endsWith('.html') ||
                name.endsWith('.css') ||
                name.endsWith('.js') ||
                name.endsWith('.py') ||
                name.endsWith('.java') ||
                name.endsWith('.c') ||
                name.endsWith('.cpp') ||
                name.endsWith('.h') ||
                name.endsWith('.sh') ||
                name.endsWith('.yaml') ||
                name.endsWith('.yml')) {
                try {
                    return await readTextFile(file);
                } catch (error) {
                    console.error('Error reading text file:', error);
                    return `[Error reading text file: ${error.message}]`;
                }
            }

            // For unsupported types, return null (will be handled differently)
            return null;
        }

        function renderAttachedFiles() {
            const container = document.getElementById('attached-files');
            container.innerHTML = '';

            attachedFiles.forEach((file, index) => {
                const div = document.createElement('div');
                div.className = 'attached-file';

                // Determine file type indicator
                let typeIndicator = '';
                if (file.type.startsWith('image/')) {
                    typeIndicator = '🖼️ ';
                } else if (file.extractedText) {
                    if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                        typeIndicator = '📄 ';
                    } else {
                        typeIndicator = '📝 ';
                    }
                } else {
                    typeIndicator = '📎 ';
                }

                div.innerHTML = `
                    <span>${typeIndicator}${escapeHtml(file.name)} (${formatFileSize(file.size)})</span>
                    <button onclick="removeAttachedFile(${index})">✕</button>
                `;
                container.appendChild(div);
            });
        }

        function removeAttachedFile(index) {
            attachedFiles.splice(index, 1);
            renderAttachedFiles();
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function showStopButton() {
            document.getElementById('send-btn').style.display = 'none';
            document.getElementById('stop-btn').style.display = 'block';
            // In autonomous mode, hide auto button when stop button is shown
            if (multiModelMode === 'autonomous') {
                document.getElementById('auto-btn').style.display = 'none';
            }
        }

        function hideStopButton() {
            document.getElementById('stop-btn').style.display = 'none';
            // In autonomous mode, restore auto button instead of send button
            if (multiModelMode === 'autonomous') {
                document.getElementById('auto-btn').style.display = 'block';
            } else {
                document.getElementById('send-btn').style.display = 'block';
            }
        }

        function stopGeneration() {
            // Set flag to prevent subsequent models from responding
            userStoppedGeneration = true;

            // Stop autonomous mode if running
            if (isAutonomousRunning) {
                isAutonomousRunning = false;
                const autoBtn = document.getElementById('auto-btn');
                autoBtn.textContent = 'Start Auto';
                autoBtn.style.background = '#4a9eff';
            }

            // Abort all ongoing requests
            currentAbortControllers.forEach(controller => {
                try {
                    controller.abort();
                } catch (e) {
                    console.error('Error aborting request:', e);
                }
            });
            currentAbortControllers = [];

            // Reset UI state
            isStreaming = false;
            stopBackgroundAudio(); // Stop silent audio when stopped
            hideStopButton();
            document.getElementById('send-btn').disabled = false;
        }

        async function sendMessage() {
            if (isStreaming) return;

            const input = document.getElementById('message-input');
            const messageText = input.value.trim();

            // Handle prefill mode
            if (isPrefilling) {
                await sendPrefill(messageText);
                return;
            }

            if (!messageText && attachedFiles.length === 0) return;
            if (models.length === 0) {
                alert('Please configure at least one model in Settings');
                return;
            }

            if (getTotalModelInstances() === 0) {
                alert('Please select at least one model');
                return;
            }

            const userMessage = {
                role: 'user',
                content: messageText,
                files: attachedFiles.length > 0 ? [...attachedFiles] : null,
                timestamp: new Date().toISOString()
            };

            if (editingMessageIndex !== null) {
                currentConversation = currentConversation.slice(0, editingMessageIndex);
                currentConversation.push(userMessage);
                editingMessageIndex = null;
                showEditIndicator(false);
            } else {
                currentConversation.push(userMessage);
            }

            input.value = '';
            attachedFiles = [];
            renderAttachedFiles();
            renderConversation();
            saveToStorage();

            // Start streaming response
            isStreaming = true;
            userStoppedGeneration = false; // Reset the stop flag for new message
            currentAbortControllers = [];
            showStopButton();
            startBackgroundAudio(); // Keep iOS active during generation
            renderConversation();

            try {
                if (multiModelMode === 'parallel') {
                    await handleParallelMode();
                } else if (multiModelMode === 'serial') {
                    await handleSerialMode();
                } else if (multiModelMode === 'rotating') {
                    await handleRotatingMode();
                }
            } catch (error) {
                console.error('Error:', error);

                // Remove any empty assistant messages that were added before the error
                removeEmptyAssistantMessages();

                // Add user-friendly error message
                const errorMessage = {
                    role: 'assistant',
                    content: `Error: ${error.message}\n\nTroubleshooting:\n• Check your API key in Settings\n• Verify your model configuration\n• Ensure you have internet connection`,
                    timestamp: new Date().toISOString()
                };
                currentConversation.push(errorMessage);
                renderConversation();
            }

            // Final cleanup: Remove any empty assistant messages that may have slipped through
            removeEmptyAssistantMessages();

            isStreaming = false;
            stopBackgroundAudio(); // Stop silent audio when done
            currentAbortControllers = [];
            hideStopButton();
            renderConversation();
            saveToStorage();
        }

        async function sendPrefill(prefillContent) {
            // Prefill mode: create assistant messages with prefilled content that models continue
            if (models.length === 0) {
                alert('Please configure at least one model in Settings');
                cancelPrefillMode();
                return;
            }

            if (getTotalModelInstances() === 0) {
                alert('Please select at least one model');
                cancelPrefillMode();
                return;
            }

            // Reset prefill mode UI
            isPrefilling = false;
            showPrefillIndicator(false);
            const input = document.getElementById('message-input');
            input.value = '';
            input.placeholder = 'Type a message... (Click Send button to send)';

            renderConversation();
            saveToStorage();

            // Start streaming response
            isStreaming = true;
            userStoppedGeneration = false;
            currentAbortControllers = [];
            showStopButton();
            startBackgroundAudio();
            renderConversation();

            try {
                // In prefill mode, we use a special handler that pre-populates the assistant message
                await handlePrefillMode(prefillContent);
            } catch (error) {
                console.error('Error:', error);

                // Remove any empty assistant messages that were added before the error
                currentConversation = currentConversation.filter(msg => {
                    if (msg.role === 'assistant') {
                        return msg.content || msg.thinking || (msg.images && msg.images.length > 0);
                    }
                    return true;
                });

                const errorMessage = {
                    role: 'assistant',
                    content: `Error: ${error.message}`,
                    timestamp: new Date().toISOString()
                };
                currentConversation.push(errorMessage);
                renderConversation();
            }

            // Final cleanup
            removeEmptyAssistantMessages();

            isStreaming = false;
            stopBackgroundAudio();
            currentAbortControllers = [];
            hideStopButton();
            renderConversation();
            saveToStorage();
        }

        async function handlePrefillMode(prefillContent) {
            // Similar to parallel mode but with prefilled content
            // For simplicity, use the first selected model for prefill continuation
            const expandedIndices = expandModelEntries();
            const modelIndex = expandedIndices[0];
            const model = models[modelIndex];

            const assistantMessage = {
                role: 'assistant',
                content: prefillContent || '',
                thinking: '',
                images: [],
                modelName: model.name,
                timestamp: new Date().toISOString()
            };
            currentConversation.push(assistantMessage);
            renderConversation();

            try {
                await streamResponseWithPrefill(model, assistantMessage, prefillContent);
            } catch (error) {
                console.error('Error in prefill mode:', error);
                if (!assistantMessage.content) {
                    assistantMessage.content = `Error: ${error.message}`;
                }
                renderConversation();
            }

            saveToStorage();
            renderConversation();
        }

        async function handleParallelMode() {
            // All models answer independently in parallel, repeated for iterationCount times
            const expandedIndices = expandModelEntries();
            for (let iteration = 0; iteration < iterationCount; iteration++) {
                const promises = expandedIndices.map(async (modelIndex) => {
                    const model = models[modelIndex];
                    const assistantMessage = {
                        role: 'assistant',
                        content: '',
                        thinking: '',
                        images: [],
                        modelName: model.name,
                        timestamp: new Date().toISOString()
                    };
                    currentConversation.push(assistantMessage);
                    renderConversation();

                    try {
                        await streamResponse(model, assistantMessage);
                    } catch (error) {
                        console.error('Error in parallel mode:', error);
                        // Set error message in the assistant message instead of empty content
                        assistantMessage.content = `Error: ${error.message}`;
                        renderConversation();
                    }
                });

                await Promise.all(promises);

                // Save after each iteration completes
                saveToStorage();
                renderConversation();
            }
        }

        async function handleSerialMode() {
            // Models answer sequentially, each seeing previous responses, repeated for iterationCount times
            const expandedIndices = expandModelEntries();
            for (let iteration = 0; iteration < iterationCount; iteration++) {
                for (let i = 0; i < expandedIndices.length; i++) {
                    // Check if user stopped generation
                    if (userStoppedGeneration) {
                        console.log('User stopped generation, breaking out of serial mode');
                        return;
                    }

                    const modelIndex = expandedIndices[i];
                    const model = models[modelIndex];
                    const assistantMessage = {
                        role: 'assistant',
                        content: '',
                        thinking: '',
                        images: [],
                        modelName: model.name,
                        timestamp: new Date().toISOString()
                    };
                    currentConversation.push(assistantMessage);
                    renderConversation();

                    try {
                        await streamResponse(model, assistantMessage);
                    } catch (error) {
                        console.error('Error in serial mode:', error);
                        // Set error message in the assistant message instead of empty content
                        assistantMessage.content = `Error: ${error.message}`;
                        renderConversation();
                    }

                    // Save and render after each model completes so next model sees the response
                    saveToStorage();
                    renderConversation();

                    // Add delay before next model (unless it's the last model of the last iteration)
                    if (responseDelay > 0 && !(iteration === iterationCount - 1 && i === expandedIndices.length - 1)) {
                        await new Promise(resolve => setTimeout(resolve, responseDelay));
                    }
                }
            }
        }

        async function handleRotatingMode() {
            // Serial mode with rotating order, repeated for iterationCount times
            const expandedIndices = expandModelEntries();
            for (let iteration = 0; iteration < iterationCount; iteration++) {
                const orderedIndices = [...expandedIndices];

                // Rotate based on rotationIndex
                for (let i = 0; i < rotationIndex % orderedIndices.length; i++) {
                    orderedIndices.push(orderedIndices.shift());
                }

                // Process in rotated order
                for (let i = 0; i < orderedIndices.length; i++) {
                    // Check if user stopped generation
                    if (userStoppedGeneration) {
                        console.log('User stopped generation, breaking out of rotating mode');
                        return;
                    }

                    const modelIndex = orderedIndices[i];
                    const model = models[modelIndex];
                    const assistantMessage = {
                        role: 'assistant',
                        content: '',
                        thinking: '',
                        images: [],
                        modelName: model.name,
                        timestamp: new Date().toISOString()
                    };
                    currentConversation.push(assistantMessage);
                    renderConversation();

                    try {
                        await streamResponse(model, assistantMessage);
                    } catch (error) {
                        console.error('Error in rotating mode:', error);
                        // Set error message in the assistant message instead of empty content
                        assistantMessage.content = `Error: ${error.message}`;
                        renderConversation();
                    }

                    // Save and render after each model completes so next model sees the response
                    saveToStorage();
                    renderConversation();

                    // Add delay before next model (unless it's the last model of the last iteration)
                    if (responseDelay > 0 && !(iteration === iterationCount - 1 && i === orderedIndices.length - 1)) {
                        await new Promise(resolve => setTimeout(resolve, responseDelay));
                    }
                }

                // Increment rotation for next iteration
                rotationIndex++;
                saveToStorage();
            }
        }

        async function handleAutonomousRound() {
            // Check if user stopped generation
            if (userStoppedGeneration || !isAutonomousRunning) {
                console.log('User stopped generation or autonomous mode ended');
                return;
            }

            // In autonomous mode, models converse with each other in rotating order
            const expandedIndices = expandModelEntries();
            const orderedIndices = [...expandedIndices];

            // Rotate based on rotationIndex
            for (let i = 0; i < rotationIndex % orderedIndices.length; i++) {
                orderedIndices.push(orderedIndices.shift());
            }

            // Pick the next model in rotation
            const modelIndex = orderedIndices[0];
            const model = models[modelIndex];

            const assistantMessage = {
                role: 'assistant',
                content: '',
                thinking: '',
                images: [],
                modelName: model.name,
                timestamp: new Date().toISOString()
            };

            currentConversation.push(assistantMessage);
            renderConversation();

            try {
                await streamResponse(model, assistantMessage);
            } catch (error) {
                console.error('Error in autonomous round:', error);
                // Set error message in the assistant message instead of empty content
                assistantMessage.content = `Error: ${error.message}`;
                renderConversation();
            }

            // Increment rotation and save
            rotationIndex++;
            saveToStorage();
        }

        function resolveApiKey(model) {
            // If model has api_key_id, look up the key
            if (model.api_key_id) {
                const key = apiKeys.find(k => k.id === model.api_key_id);
                if (key) {
                    return key.value;
                }
                throw new Error(`API key not found for ID: ${model.api_key_id}`);
            }
            // Otherwise use the direct api_key
            return model.api_key;
        }

        // Strip company prefix from model name (e.g., "Anthropic: Claude 3 Opus" -> "Claude 3 Opus")
        function stripCompanyPrefix(name) {
            if (!name || typeof name !== 'string') return name;
            // Match pattern: "Company Name: Model Name" or "Company: Model Name"
            const match = name.match(/^[A-Za-z0-9\s]+:\s*(.+)$/);
            return match ? match[1] : name;
        }

        // Sanitize model names to prevent prompt injection
        function sanitizeModelName(name) {
            if (!name || typeof name !== 'string') {
                return 'Unknown Model';
            }

            // Strip company prefix first
            let sanitized = stripCompanyPrefix(name);

            // Remove control characters and normalize whitespace
            sanitized = sanitized
                .replace(/[\r\n\t]+/g, ' ')  // Replace newlines and tabs with spaces
                .replace(/\s+/g, ' ')         // Collapse multiple spaces
                .trim();

            // Limit length to prevent abuse
            if (sanitized.length > 100) {
                sanitized = sanitized.substring(0, 100) + '...';
            }

            // If empty after sanitization, use default
            if (!sanitized) {
                return 'Unknown Model';
            }

            return sanitized;
        }

        // Check if conversation requires multi-model handling (either multiple selected or history has multiple)
        function isMultiModelContext() {
            if (getTotalModelInstances() > 1) return true;
            // Check if conversation history has messages from multiple distinct models
            const modelsInHistory = new Set();
            for (const msg of currentConversation) {
                if (msg.role === 'assistant' && msg.modelName) {
                    modelsInHistory.add(msg.modelName);
                    if (modelsInHistory.size > 1) return true;
                }
            }
            return false;
        }

        // Get all model names that have participated in the conversation
        function getModelsInConversation() {
            const modelsInHistory = new Set();
            for (const msg of currentConversation) {
                if (msg.role === 'assistant' && msg.modelName) {
                    modelsInHistory.add(msg.modelName);
                }
            }
            // Also include currently selected models
            for (const entry of selectedModelEntries) {
                if (models[entry.modelIndex] && models[entry.modelIndex].name) {
                    modelsInHistory.add(models[entry.modelIndex].name);
                }
            }
            return Array.from(modelsInHistory);
        }

        // Escape special regex characters in a string
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function buildSystemPrompt(model) {
            let systemPrompt = '';

            // Add model identity information if enabled
            if (enableModelIdentity && model.name) {
                const sanitizedName = sanitizeModelName(model.name);
                const now = new Date().toLocaleString();

                systemPrompt = `You are ${sanitizedName}. This is your name for this conversation—how others address you and how you should refer to yourself. If unfamiliar, it was assigned after your training. Current time: ${now}.\n\n`;
            }

            // Use activePromptId if set, otherwise fall back to model's system_prompt
            if (activePromptId) {
                const prompt = systemPrompts.find(p => p.id === activePromptId);
                if (prompt) {
                    systemPrompt += prompt.content;
                }
            } else if (model.system_prompt && model.system_prompt.trim()) {
                systemPrompt += model.system_prompt;
            }

            return systemPrompt.trim();
        }

        async function streamResponse(model, assistantMessage) {
            const messages = buildMessagesForAPI(model, assistantMessage);
            await streamOpenAI(model, messages, assistantMessage);
        }

        async function streamResponseWithPrefill(model, assistantMessage, prefillContent) {
            // Build messages, excluding the current assistant message we're generating
            const messages = buildMessagesForAPI(model, assistantMessage);

            // Add the prefilled assistant message that the model should continue from
            if (prefillContent) {
                messages.push({
                    role: 'assistant',
                    content: prefillContent
                });
            }

            await streamOpenAI(model, messages, assistantMessage);
        }

        function buildMessagesForAPI(model, excludeMessage = null) {
            const messages = [];

            // Filter messages based on mode
            let conversationToUse = [...currentConversation];

            // In parallel mode, only include messages from this specific model and user messages
            if (multiModelMode === 'parallel') {
                conversationToUse = conversationToUse.filter(msg =>
                    msg.role === 'user' ||
                    (msg.role === 'assistant' && msg.modelName === model.name)
                );
            }

            // Find the most recent user message BEFORE applying history limit (to always include its files)
            let mostRecentUserMsg = null;
            for (let i = conversationToUse.length - 1; i >= 0; i--) {
                if (conversationToUse[i].role === 'user' && conversationToUse[i] !== excludeMessage) {
                    mostRecentUserMsg = conversationToUse[i];
                    break;
                }
            }

            // Apply message history limit (0 = all messages)
            if (messageHistoryLimit > 0 && conversationToUse.length > messageHistoryLimit) {
                conversationToUse = conversationToUse.slice(-messageHistoryLimit);

                // If mostRecentUserMsg was cut off, ensure it's included
                if (mostRecentUserMsg && !conversationToUse.includes(mostRecentUserMsg)) {
                    conversationToUse.unshift(mostRecentUserMsg);
                }
            }

            for (const msg of conversationToUse) {
                if (msg === excludeMessage) continue; // Skip the message we're currently generating

                if (msg.role === 'user') {
                    let content;

                    // Always include files from the most recent user message, or if includeFilesInHistory is enabled
                    const shouldIncludeFiles = msg.files && msg.files.length > 0 &&
                                               (msg === mostRecentUserMsg || includeFilesInHistory);

                    if (shouldIncludeFiles) {
                        // Has files and should include them - use array format (OpenAI-compatible)
                        content = [];

                        if (msg.content) {
                            // Trim leading/trailing whitespace from user messages too
                            let textContent = msg.content.trim();

                            // With multiple models (or history from multiple), prefix user messages for flat hierarchy
                            if (isMultiModelContext()) {
                                textContent = `${userIdentifier} said: ${textContent}`;
                            }

                            content.push({ type: 'text', text: textContent });
                        }

                        for (const file of msg.files) {
                            if (file.type.startsWith('image/')) {
                                // OpenAI-compatible format (used by OpenRouter)
                                content.push({
                                    type: 'image_url',
                                    image_url: {
                                        url: `data:${file.type};base64,${file.base64}`
                                    }
                                });
                            } else if (file.extractedText) {
                                // For files with extracted text content (PDFs, text files, etc.)
                                const safeName = sanitizeFileName(file.name);
                                content.push({
                                    type: 'text',
                                    text: `[File: ${safeName}]\n\n${file.extractedText}`
                                });
                            } else {
                                // For unsupported file types, just mention it
                                const safeName = sanitizeFileName(file.name);
                                content.push({
                                    type: 'text',
                                    text: `[Attached file: ${safeName} - content extraction not supported for this file type]`
                                });
                            }
                        }
                    } else {
                        // No files or should not include files - use simple string format
                        // Trim leading/trailing whitespace from user messages too
                        content = (msg.content || '').trim();

                        // With multiple models (or history from multiple), prefix user messages for flat hierarchy
                        if (isMultiModelContext()) {
                            content = `${userIdentifier} said: ${content}`;
                        }
                    }

                    messages.push({
                        role: 'user',
                        content: content
                    });
                } else if (msg.role === 'assistant') {
                    // Build content string from all available content sources
                    let content = '';

                    // Check if content acts as a duplicate of thinking (prevents double-sending)
                    const isDuplicate = msg.content && msg.thinking &&
                                       msg.content.trim() === msg.thinking.trim();

                    // Only add thinking if it's NOT a duplicate of the main content
                    if (msg.thinking && msg.thinking.trim() && !isDuplicate) {
                        content += `[Thinking: ${msg.thinking.trim()}]\n\n`;
                    }

                    // Include main content
                    if (msg.content && msg.content.trim()) {
                        content += msg.content.trim();
                    }

                    // Include image descriptions if images exist
                    if (msg.images && msg.images.length > 0) {
                        if (content) content += '\n\n';
                        content += `[Generated ${msg.images.length} image(s)]`;
                    }

                    // Skip only if there's truly no content at all
                    if (!content.trim()) {
                        continue;
                    }

                    // With multiple models (or history from multiple): use 'user' role with name prefix for flat hierarchy
                    // With single model: keep traditional 'assistant' role
                    if (isMultiModelContext()) {
                        if (msg.modelName) {
                            const sanitizedModelName = sanitizeModelName(msg.modelName);
                            content = `${sanitizedModelName} said: ${content}`;
                        }
                        messages.push({
                            role: 'user',
                            content: content
                        });
                    } else {
                        messages.push({
                            role: 'assistant',
                            content: content
                        });
                    }
                }
            }

            return messages;
        }

        async function streamOpenAI(model, messages, assistantMessage) {
            // OpenAI Responses API format
            // Convert messages array to input format for Responses API
            const input = messages.map(msg => ({
                role: msg.role,
                content: msg.content
            }));

            const body = {
                model: model.model_id,
                input: input,
                stream: true
            };

            // Add system prompt as instructions (Responses API format)
            const systemPrompt = buildSystemPrompt(model);
            if (systemPrompt) {
                body.instructions = systemPrompt;
            }

            // Add optional parameters if specified
            // Responses API uses max_output_tokens instead of max_tokens
            if (model.max_output_tokens !== undefined && model.max_output_tokens !== null) {
                body.max_output_tokens = model.max_output_tokens;
            } else if (model.max_tokens !== undefined && model.max_tokens !== null) {
                body.max_output_tokens = model.max_tokens;
            }
            if (model.temperature !== undefined && model.temperature !== null) {
                body.temperature = model.temperature;
            }
            if (model.top_p !== undefined && model.top_p !== null) {
                body.top_p = model.top_p;
            }
            if (model.frequency_penalty !== undefined && model.frequency_penalty !== null) {
                body.frequency_penalty = model.frequency_penalty;
            }
            if (model.presence_penalty !== undefined && model.presence_penalty !== null) {
                body.presence_penalty = model.presence_penalty;
            }
            if (model.seed !== undefined && model.seed !== null) {
                body.seed = model.seed;
            }
            if (model.stop && model.stop.length > 0) {
                body.stop = model.stop;
            }
            if (model.tools) {
                body.tools = model.tools;
            }
            if (model.tool_choice) {
                body.tool_choice = model.tool_choice;
            }
            // Add reasoning parameter for O1+ models
            if (enableExtendedThinking) {
                body.reasoning = { effort: thinkingEffort };
            } else if (model.reasoning) {
                body.reasoning = model.reasoning;
            }
            // Text output format configuration
            if (model.text) {
                body.text = model.text;
            }

            // Build dynamic stop sequences for multi-model conversations
            if (isMultiModelContext()) {
                let dynamicStopSequences = [];
                dynamicStopSequences.push(`\n${userIdentifier} said:`);

                for (const name of getModelsInConversation()) {
                    const sanitized = sanitizeModelName(name);
                    dynamicStopSequences.push(`\n${sanitized} said:`);
                }

                dynamicStopSequences = [...new Set(dynamicStopSequences)];
                const existingStops = body.stop || [];
                body.stop = [...new Set([...dynamicStopSequences, ...existingStops])].slice(0, 4);
            }

            const apiKey = resolveApiKey(model);

            // Validate API key
            if (!apiKey || apiKey.includes('your-')) {
                throw new Error('Invalid or missing API key. Please add a valid OpenRouter API key in Settings.');
            }

            // Build headers for OpenRouter
            const headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`,
                'HTTP-Referer': window.location.href,
                'X-Title': 'OpenRouter Responses API Chat'
            };

            // Add custom headers
            if (model.headers) {
                Object.assign(headers, model.headers);
            }

            let response;
            const controller = new AbortController();
            currentAbortControllers.push(controller);

            try {
                const timeoutMs = model.timeout || 120000;
                const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

                response = await fetch(model.endpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
            } catch (e) {
                console.error('Fetch error:', e);
                if (e.name === 'AbortError') {
                    throw new Error('Request stopped.');
                }
                throw new Error(`Network error: ${e.message}. Check your internet connection and make sure the endpoint is correct.`);
            }

            if (!response.ok) {
                let errorText;
                try {
                    errorText = await response.text();
                    console.error('API error response:', errorText);

                    try {
                        const errorJson = JSON.parse(errorText);
                        if (errorJson.error && errorJson.error.message) {
                            errorText = errorJson.error.message;
                        }
                    } catch (e) {
                        // Not JSON, use as-is
                    }
                } catch (e) {
                    errorText = 'Could not read error response';
                }

                if (response.status === 401) {
                    throw new Error(`Authentication failed. Your API key may be invalid or expired. Status: ${response.status}`);
                } else if (response.status === 402) {
                    throw new Error(`Insufficient credits. Please add credits to your OpenRouter account. Status: ${response.status}`);
                } else if (response.status === 429) {
                    throw new Error(`Rate limit exceeded. Please wait a moment and try again. Status: ${response.status}`);
                } else {
                    throw new Error(`API error ${response.status}: ${errorText}`);
                }
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let finishReason = null;
            let hasReceivedContent = false;
            let isFirstContentChunk = true;
            let isFirstThinkingChunk = true;
            let currentEventType = null;

            while (true) {
                if (controller.signal.aborted) {
                    await reader.cancel();
                    break;
                }

                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();

                for (const line of lines) {
                    // Handle event type lines (Responses API format)
                    if (line.startsWith('event: ')) {
                        currentEventType = line.slice(7).trim();
                        continue;
                    }

                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;

                        try {
                            const parsed = JSON.parse(data);

                            // Check for error in response
                            if (parsed.error) {
                                const errorMsg = parsed.error.message || 'Unknown error from API';
                                const errorCode = parsed.error.code;

                                if (errorCode === 'rate_limit_exceeded' || errorCode === 429) {
                                    throw new Error(`Rate limit exceeded: ${errorMsg}. Try waiting or using a different model.`);
                                } else if (errorCode === 'insufficient_quota' || errorCode === 402) {
                                    throw new Error(`Insufficient quota: ${errorMsg}. Check your OpenRouter account balance.`);
                                } else if (errorCode === 'invalid_request_error' || errorCode === 400) {
                                    throw new Error(`Bad request: ${errorMsg}`);
                                } else {
                                    throw new Error(`API error (${errorCode || 'unknown'}): ${errorMsg}`);
                                }
                            }

                            // Handle Responses API streaming events
                            const eventType = parsed.type || currentEventType;

                            // Handle text delta events (main content)
                            if (eventType === 'response.output_text.delta' || parsed.delta !== undefined) {
                                const textDelta = parsed.delta || '';
                                if (textDelta) {
                                    const contentToAdd = isFirstContentChunk ? textDelta.trimStart() : textDelta;
                                    assistantMessage.content += contentToAdd;
                                    hasReceivedContent = true;
                                    isFirstContentChunk = false;
                                    scheduleRender();
                                }
                            }

                            // Handle reasoning/thinking content (for O1+ models)
                            if (eventType === 'response.reasoning.delta' || parsed.reasoning_delta !== undefined) {
                                const thinkingDelta = parsed.reasoning_delta || parsed.delta || '';
                                if (thinkingDelta) {
                                    const thinkingToAdd = isFirstThinkingChunk ? thinkingDelta.trimStart() : thinkingDelta;
                                    assistantMessage.thinking += thinkingToAdd;
                                    hasReceivedContent = true;
                                    isFirstThinkingChunk = false;
                                    scheduleRender();
                                }
                            }

                            // Handle response completion
                            if (eventType === 'response.completed' || eventType === 'response.done') {
                                if (parsed.response?.status) {
                                    finishReason = parsed.response.status;
                                }
                                // Extract any final content from completed response
                                if (parsed.response?.output) {
                                    for (const output of parsed.response.output) {
                                        if (output.type === 'message' && output.content) {
                                            for (const content of output.content) {
                                                if (content.type === 'output_text' && content.text) {
                                                    if (!assistantMessage.content) {
                                                        assistantMessage.content = content.text.trim();
                                                        hasReceivedContent = true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            // Also handle Chat Completions format for backwards compatibility
                            // (in case endpoint is set to chat/completions)
                            const delta = parsed.choices?.[0]?.delta;
                            if (delta?.content) {
                                if (typeof delta.content === 'string') {
                                    const contentToAdd = isFirstContentChunk ? delta.content.trimStart() : delta.content;
                                    assistantMessage.content += contentToAdd;
                                    hasReceivedContent = true;
                                    isFirstContentChunk = false;
                                    scheduleRender();
                                }
                            }

                            if (parsed.choices?.[0]?.finish_reason) {
                                finishReason = parsed.choices[0].finish_reason;
                            }

                            // Handle reasoning in Chat Completions format
                            const thinkingContent = delta?.reasoning || delta?.thinking;
                            if (thinkingContent) {
                                const thinkingToAdd = isFirstThinkingChunk ? thinkingContent.trimStart() : thinkingContent;
                                assistantMessage.thinking += thinkingToAdd;
                                hasReceivedContent = true;
                                isFirstThinkingChunk = false;
                                scheduleRender();
                            }

                        } catch (e) {
                            console.error('Error parsing SSE:', e, 'Line:', line);
                        }
                    }
                }
            }

            // Strip any "X said:" patterns that leaked through stop sequences
            if (isMultiModelContext() && assistantMessage.content) {
                const participantNames = [
                    userIdentifier,
                    ...getModelsInConversation().map(n => sanitizeModelName(n))
                ];

                for (const name of participantNames) {
                    const pattern = new RegExp(`\\n${escapeRegex(name)} said:[\\s\\S]*$`, 'i');
                    assistantMessage.content = assistantMessage.content.replace(pattern, '');
                }

                assistantMessage.content = assistantMessage.content.trimEnd();
            }

            // Promote thinking to content when content is empty
            const hasContentText = assistantMessage.content && assistantMessage.content.trim().length > 0;
            const hasThinkingText = assistantMessage.thinking && assistantMessage.thinking.trim().length > 0;

            if (!hasContentText && hasThinkingText) {
                assistantMessage.content = assistantMessage.thinking;
            }

            // Validate that we received content
            if (controller.signal.aborted) {
                return;
            }
            if (!hasReceivedContent && !assistantMessage.content && !assistantMessage.thinking && !assistantMessage.images?.length) {
                console.warn('Model completed streaming with no content', {
                    model: model.name,
                    model_id: model.model_id,
                    finishReason: finishReason,
                    hasReceivedContent: hasReceivedContent,
                    contentLength: assistantMessage.content?.length || 0,
                    thinkingLength: assistantMessage.thinking?.length || 0,
                    imageCount: assistantMessage.images?.length || 0,
                    messageCount: messages.length,
                    timestamp: new Date().toISOString()
                });

                if (finishReason === 'content_filter') {
                    throw new Error(`${model.name} declined to respond due to content filter. Try rephrasing your message.`);
                } else if (finishReason === 'length') {
                    throw new Error(`${model.name} hit token limit before responding. Try reducing message history or increasing max_output_tokens.`);
                } else if (finishReason === 'stop') {
                    throw new Error(`${model.name} stopped immediately without generating content. This may indicate:\n• Content filtering or safety refusal\n• Prompt formatting issues\n• Model configuration problems (check max_output_tokens, temperature)\n• API or model instability\n\nTry:\n• Rephrasing your message\n• Clearing conversation history\n• Using a different model`);
                } else if (finishReason === 'completed' || finishReason === 'done') {
                    // Model sent completion signal without new content - silently ignore
                    // This can happen with some models after they finish responding
                    return;
                } else if (finishReason) {
                    throw new Error(`${model.name} stopped with reason: ${finishReason} (no content generated)`);
                } else {
                    throw new Error(`${model.name} completed streaming but provided no response. This may be a model issue or API error.`);
                }
            }
        }

        // Check if user is scrolled near the bottom of the chat
        function isNearBottom(container, threshold = 100) {
            return container.scrollHeight - container.scrollTop - container.clientHeight < threshold;
        }

        function scheduleRender() {
            if (renderTimer) return;
            renderTimer = requestAnimationFrame(() => {
                renderTimer = null;
                renderConversation();
            });
        }

        // Helper to check if content is essentially the same as thinking (promoted)
        function isContentPromotedThinking(content, thinking) {
            if (!content || !thinking) return false;
            const c = content.trim();
            const t = thinking.trim();
            if (!c || !t) return false;
            // Exact match
            if (c === t) return true;
            // Content is contained in thinking (thinking was truncated to content)
            if (t.includes(c) && c.length > t.length * 0.8) return true;
            // Thinking is contained in content (content has minor additions)
            if (c.includes(t) && t.length > c.length * 0.8) return true;
            return false;
        }

        // Helper to build assistant message HTML (extracted for reuse)
        function buildAssistantMessageHtml(msg, index) {
            const isPromotedThinking = isContentPromotedThinking(msg.content, msg.thinking);
            const rendered = isPromotedThinking ? '' : renderMarkdownWithLatex(msg.content);
            let contentHtml = '';

            // Editable model name header with role switch button
            const displayName = msg.modelName ? stripCompanyPrefix(msg.modelName) : 'Assistant';
            contentHtml += `<div style="font-size: 12px; color: #888; margin-bottom: 8px; font-weight: 600; display: flex; align-items: center; gap: 4px;">
                <span class="editable-name" onclick="editMessageName(${index})" title="Click to edit name">${escapeHtml(displayName)}</span>
                <button class="role-switch-btn" onclick="switchMessageRole(${index})" title="Convert to user message">→ User</button>
            </div>`;

            const isStreamingThisMessage = isStreaming && currentConversation[currentConversation.length - 1] === msg;
            if (isStreamingThisMessage && msg.thinking && !msg.content) {
                contentHtml += `
                    <div class="inline-thinking-indicator">
                        <span>Thinking...</span>
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                `;
            }

            if (msg.thinking) {
                const hasThinking = msg.thinking && msg.thinking.trim().length > 0;
                const hasRealContent = msg.content && msg.content.trim().length > 0 && !isPromotedThinking;
                const shouldAutoExpand = !hasRealContent && hasThinking;
                // Use message timestamp as stable key (fallback to index for old messages)
                const msgKey = msg.timestamp || `idx-${index}`;
                // Use view state (doesn't persist to storage/exports)
                const isCollapsed = thinkingCollapseState[msgKey] !== undefined ? thinkingCollapseState[msgKey] : !shouldAutoExpand;

                const thinkingId = `thinking-${msgKey}`;
                contentHtml += `
                    <div class="thinking-toggle" onclick="toggleThinking('${thinkingId}', '${msgKey}')">
                        Chain of Thought (click to ${isCollapsed ? 'expand' : 'collapse'})
                    </div>
                    <div id="${thinkingId}" class="thinking-content${isCollapsed ? ' collapsed' : ''}">
                        ${escapeHtml(msg.thinking)}
                    </div>
                `;

                if (!hasRealContent && hasThinking) {
                    contentHtml += `
                        <div style="font-size: 12px; color: #ff8c42; font-style: italic; margin-top: 4px;">
                            (Response is in the Chain of Thought section above)
                        </div>
                    `;
                }
            }

            if (rendered) {
                contentHtml += `<div class="message-content">${rendered}</div>`;
            }

            if (msg.images && msg.images.length > 0) {
                for (const image of msg.images) {
                    contentHtml += `<div class="file-preview"><img src="${escapeHtml(image.url)}" alt="Generated image" style="max-width: 100%; height: auto; border-radius: 6px; margin-top: 12px;"></div>`;
                }
            }

            contentHtml += `
                <div class="message-actions">
                    <button onclick="editAssistantMessageInline(${index})">Edit</button>
                    <button onclick="continueResponse(${index})">Continue</button>
                    <button onclick="regenerateResponse(${index})">Regenerate</button>
                </div>
            `;

            return contentHtml;
        }

        // Update an existing assistant message element in place
        function updateAssistantMessage(element, msg, index) {
            element.innerHTML = buildAssistantMessageHtml(msg, index);
        }

        function renderConversation() {
            const container = document.getElementById('chat-messages');
            const wasNearBottom = isNearBottom(container);

            // During streaming, try to update only assistant messages for better performance
            if (isStreaming && container.children.length === currentConversation.length && currentConversation.length > 0) {
                let updatedAny = false;
                // Update all assistant messages (handles parallel streaming)
                for (let i = 0; i < currentConversation.length; i++) {
                    const msg = currentConversation[i];
                    if (msg.role === 'assistant') {
                        const element = container.children[i];
                        if (element && element.classList.contains('assistant')) {
                            updateAssistantMessage(element, msg, i);
                            updatedAny = true;
                        }
                    }
                }
                if (updatedAny) {
                    if (wasNearBottom) {
                        container.scrollTop = container.scrollHeight;
                    }
                    return;
                }
            }

            container.innerHTML = '';

            currentConversation.forEach((msg, index) => {
                if (msg.role === 'user') {
                    const div = document.createElement('div');
                    div.className = 'message user';

                    // Editable user name header with role switch button
                    const displayName = msg.senderName || userIdentifier || 'User';
                    let contentHtml = `<div style="font-size: 12px; color: #888; margin-bottom: 8px; font-weight: 600; display: flex; align-items: center; gap: 4px;">
                        <span class="editable-name" onclick="editMessageName(${index})" title="Click to edit name">${escapeHtml(displayName)}</span>
                        <button class="role-switch-btn" onclick="switchMessageRole(${index})" title="Convert to assistant message">→ Assistant</button>
                    </div>`;

                    contentHtml += `<div class="message-content">${escapeHtml(msg.content)}</div>`;

                    if (msg.files) {
                        for (const file of msg.files) {
                            if (file.type.startsWith('image/')) {
                                contentHtml += `<div class="file-preview"><img src="data:${file.type};base64,${file.base64}" alt="${escapeHtml(file.name)}"></div>`;
                            } else if (file.type.startsWith('video/')) {
                                contentHtml += `<div class="file-preview"><video controls src="data:${file.type};base64,${file.base64}"></video></div>`;
                            } else if (file.extractedText) {
                                // Show file info with indicator that text was extracted
                                const previewLength = 150;
                                const preview = file.extractedText.substring(0, previewLength);
                                const hasMore = file.extractedText.length > previewLength;
                                const fileIcon = (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) ? '📄' : '📝';
                                contentHtml += `<div class="file-info" style="background: #2a2a2a; padding: 8px; border-radius: 4px; margin-top: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 4px;">${fileIcon} ${escapeHtml(file.name)} (${formatFileSize(file.size)}) - Text extracted</div>
                                    <div style="font-size: 12px; color: #888; font-style: italic;">${escapeHtml(preview)}${hasMore ? '...' : ''}</div>
                                </div>`;
                            } else {
                                contentHtml += `<div class="file-info">📎 ${escapeHtml(file.name)} (${formatFileSize(file.size)})</div>`;
                            }
                        }
                    }

                    contentHtml += `<div class="message-actions">
                        <button onclick="editUserMessageInline(${index})">Edit</button>
                        <button onclick="editMessage(${index})">Edit & Resend</button>
                        <button onclick="regenerateFromUserMessage(${index})">Regenerate</button>
                    </div>`;
                    
                    div.innerHTML = contentHtml;
                    container.appendChild(div);
                } else if (msg.role === 'assistant') {
                    const div = document.createElement('div');
                    div.className = 'message assistant';
                    div.innerHTML = buildAssistantMessageHtml(msg, index);
                    container.appendChild(div);
                }
            });

            // Only auto-scroll if user was already near bottom
            if (wasNearBottom) {
                container.scrollTop = container.scrollHeight;
            }

            // Fix scroll jitter by re-scrolling when images load (only if near bottom)
            if (wasNearBottom) {
                container.querySelectorAll('img').forEach(img => {
                    img.addEventListener('load', () => {
                        if (isNearBottom(container)) {
                            container.scrollTop = container.scrollHeight;
                        }
                    }, { once: true });
                });
            }
        }

        function toggleThinking(thinkingId, msgKey) {
            const element = document.getElementById(thinkingId);
            if (element) {
                element.classList.toggle('collapsed');

                // Update view state using message key (not saved to storage)
                thinkingCollapseState[msgKey] = element.classList.contains('collapsed');
            }
        }

        function editMessage(index) {
            const msg = currentConversation[index];
            const input = document.getElementById('message-input');
            input.value = msg.content;
            editingMessageIndex = index;

            // Show edit indicator
            showEditIndicator(true);

            // Load files if any
            if (msg.files) {
                attachedFiles = [...msg.files];
                renderAttachedFiles();
            }

            // Focus the input
            input.focus();
        }

        function showEditIndicator(show) {
            const indicator = document.getElementById('edit-indicator');
            const input = document.getElementById('message-input');
            if (show) {
                indicator.classList.add('visible');
                input.classList.add('editing');
            } else {
                indicator.classList.remove('visible');
                input.classList.remove('editing');
            }
        }

        function cancelEditMode() {
            editingMessageIndex = null;
            document.getElementById('message-input').value = '';
            attachedFiles = [];
            renderAttachedFiles();
            showEditIndicator(false);
        }

        function enterPrefillMode() {
            if (isStreaming) return;
            if (isPrefilling) return;

            // Cancel edit mode if active
            if (editingMessageIndex !== null) {
                cancelEditMode();
            }

            isPrefilling = true;
            showPrefillIndicator(true);

            const input = document.getElementById('message-input');
            input.placeholder = 'Enter the start of the assistant response...';
            input.focus();
        }

        function showPrefillIndicator(show) {
            const indicator = document.getElementById('prefill-indicator');
            const input = document.getElementById('message-input');
            if (show) {
                indicator.classList.add('visible');
                input.classList.add('prefilling');
            } else {
                indicator.classList.remove('visible');
                input.classList.remove('prefilling');
            }
        }

        function cancelPrefillMode() {
            isPrefilling = false;
            document.getElementById('message-input').value = '';
            document.getElementById('message-input').placeholder = 'Type a message... (Click Send button to send)';
            showPrefillIndicator(false);
        }

        function editMessageName(index) {
            const msg = currentConversation[index];
            if (!msg) return;

            const container = document.getElementById('chat-messages');
            const messageDiv = container.children[index];
            if (!messageDiv) return;

            // Find the name element
            const nameSpan = messageDiv.querySelector('.editable-name');
            if (!nameSpan) return;

            // Get current name
            let currentName;
            if (msg.role === 'user') {
                currentName = msg.senderName || userIdentifier || 'User';
            } else {
                currentName = msg.modelName ? stripCompanyPrefix(msg.modelName) : 'Assistant';
            }

            // Replace with input
            const parentDiv = nameSpan.parentElement;
            const originalHtml = parentDiv.innerHTML;

            parentDiv.innerHTML = `
                <div class="name-editor">
                    <input type="text" value="${escapeHtml(currentName)}" id="name-edit-input-${index}"
                           onkeydown="handleNameEditKey(event, ${index})">
                    <button onclick="saveMessageName(${index})">Save</button>
                    <button onclick="cancelNameEdit(${index})">Cancel</button>
                </div>
            `;

            // Store original HTML for cancel
            parentDiv.dataset.originalHtml = originalHtml;

            // Focus and select
            const input = document.getElementById(`name-edit-input-${index}`);
            if (input) {
                input.focus();
                input.select();
            }
        }

        function handleNameEditKey(e, index) {
            if (e.key === 'Enter') {
                saveMessageName(index);
            } else if (e.key === 'Escape') {
                cancelNameEdit(index);
            }
        }

        function saveMessageName(index) {
            const msg = currentConversation[index];
            if (!msg) return;

            const input = document.getElementById(`name-edit-input-${index}`);
            if (!input) return;

            // Sanitize the name: remove control chars, collapse whitespace, limit length
            let newName = input.value
                .replace(/[\r\n\t]+/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            if (!newName) return;
            if (newName.length > 100) newName = newName.substring(0, 100);

            // Update the message
            if (msg.role === 'user') {
                msg.senderName = newName;
            } else {
                msg.modelName = newName;
            }

            saveToStorage();
            renderConversation();
        }

        function cancelNameEdit(index) {
            const container = document.getElementById('chat-messages');
            const messageDiv = container.children[index];
            if (!messageDiv) return;

            const nameEditor = messageDiv.querySelector('.name-editor');
            if (!nameEditor) return;

            const parentDiv = nameEditor.parentElement;
            if (parentDiv && parentDiv.dataset.originalHtml) {
                parentDiv.innerHTML = parentDiv.dataset.originalHtml;
            } else {
                // Fallback: re-render the whole conversation
                renderConversation();
            }
        }

        function switchMessageRole(index) {
            const msg = currentConversation[index];
            if (!msg) return;

            if (msg.role === 'user') {
                // Convert user message to assistant message
                msg.role = 'assistant';
                msg.modelName = msg.senderName || userIdentifier || 'User';
                delete msg.senderName;
                // Keep content, clear user-specific fields if any
                delete msg.files; // Assistant messages don't have files in the same way
            } else if (msg.role === 'assistant') {
                // Convert assistant message to user message
                msg.role = 'user';
                msg.senderName = msg.modelName ? stripCompanyPrefix(msg.modelName) : 'Assistant';
                delete msg.modelName;
                // Keep content, clear assistant-specific fields
                delete msg.thinking;
                delete msg.thinkingCollapsed;
                delete msg.images;
            }

            saveToStorage();
            renderConversation();
        }

        function editUserMessageInline(index) {
            const msg = currentConversation[index];
            if (msg.role !== 'user') return;

            const container = document.getElementById('chat-messages');
            const messageDiv = container.children[index];

            // Create textarea for editing
            const textarea = document.createElement('textarea');
            textarea.value = msg.content;
            textarea.style.cssText = `
                width: 100%;
                min-height: 100px;
                max-height: 400px;
                overflow-y: auto;
                padding: 12px;
                background: #2a2a2a;
                border: 1px solid #4a4a4a;
                color: #e0e0e0;
                border-radius: 8px;
                font-family: inherit;
                font-size: 14px;
                resize: vertical;
                box-sizing: border-box;
            `;

            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'margin-top: 8px; display: flex; gap: 8px;';

            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.style.cssText = 'padding: 6px 12px; background: #4a9eff; border: none; color: white; border-radius: 4px; cursor: pointer;';
            saveBtn.onclick = () => saveInlineEdit(index, textarea.value, false);

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = 'padding: 6px 12px; background: #4a4a4a; border: none; color: #e0e0e0; border-radius: 4px; cursor: pointer;';
            cancelBtn.onclick = cancelEditInline;

            buttonContainer.appendChild(saveBtn);
            buttonContainer.appendChild(cancelBtn);

            // Replace message content with editor
            messageDiv.innerHTML = '';
            messageDiv.appendChild(textarea);
            messageDiv.appendChild(buttonContainer);
            textarea.focus();
        }

        function editAssistantMessageInline(index) {
            const msg = currentConversation[index];
            if (msg.role !== 'assistant') return;

            const container = document.getElementById('chat-messages');
            const messageDiv = container.children[index];

            // Create textarea for editing
            const textarea = document.createElement('textarea');

            // Fall back to thinking when content is empty
            let initialValue = msg.content || '';
            if (!initialValue && msg.thinking) {
                initialValue = msg.thinking;
            }
            textarea.value = initialValue;
            textarea.style.cssText = `
                width: 100%;
                min-height: 100px;
                max-height: 400px;
                overflow-y: auto;
                padding: 12px;
                background: #2a2a2a;
                border: 1px solid #4a4a4a;
                color: #e0e0e0;
                border-radius: 8px;
                font-family: inherit;
                font-size: 14px;
                resize: vertical;
                box-sizing: border-box;
            `;

            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'margin-top: 8px; display: flex; gap: 8px;';

            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.style.cssText = 'padding: 6px 12px; background: #4a9eff; border: none; color: white; border-radius: 4px; cursor: pointer;';
            saveBtn.onclick = () => saveInlineEdit(index, textarea.value, true);

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = 'padding: 6px 12px; background: #4a4a4a; border: none; color: #e0e0e0; border-radius: 4px; cursor: pointer;';
            cancelBtn.onclick = cancelEditInline;

            buttonContainer.appendChild(saveBtn);
            buttonContainer.appendChild(cancelBtn);

            // Replace message content with editor
            messageDiv.innerHTML = '';
            messageDiv.appendChild(textarea);
            messageDiv.appendChild(buttonContainer);
            textarea.focus();
        }

        function saveInlineEdit(index, newContent, truncateAfter) {
            const msg = currentConversation[index];
            if (!msg) return;

            // Update the message content
            msg.content = newContent;

            // Truncate conversation after this message if requested
            if (truncateAfter) {
                currentConversation = currentConversation.slice(0, index + 1);
            }

            saveToStorage();
            renderConversation();
        }

        function cancelEditInline() {
            editingMessageIndex = null;
            attachedFiles = [];
            renderAttachedFiles();
            showEditIndicator(false);
            renderConversation();
        }

        async function regenerateFromUserMessage(index) {
            const msg = currentConversation[index];
            if (msg.role !== 'user') return;
            if (isStreaming) return;

            // Truncate conversation to just after this user message
            currentConversation = currentConversation.slice(0, index + 1);

            renderConversation();
            saveToStorage();

            // Start streaming response (same logic as sendMessage)
            isStreaming = true;
            userStoppedGeneration = false; // Reset the stop flag for regeneration
            currentAbortControllers = [];
            showStopButton();
            startBackgroundAudio();
            renderConversation();

            try {
                if (multiModelMode === 'parallel') {
                    await handleParallelMode();
                } else if (multiModelMode === 'serial') {
                    await handleSerialMode();
                } else if (multiModelMode === 'rotating') {
                    await handleRotatingMode();
                } else if (multiModelMode === 'autonomous') {
                    await handleAutonomousMode();
                }
            } catch (error) {
                console.error('Error:', error);

                // Remove any empty assistant messages that were added before the error
                currentConversation = currentConversation.filter(msg => {
                    if (msg.role === 'assistant') {
                        return msg.content || msg.thinking || (msg.images && msg.images.length > 0);
                    }
                    return true;
                });

                // Add user-friendly error message
                const errorMessage = {
                    role: 'assistant',
                    content: `Error: ${error.message}`,
                    timestamp: new Date().toISOString()
                };
                currentConversation.push(errorMessage);
                renderConversation();
            }

            // Final cleanup
            removeEmptyAssistantMessages();

            isStreaming = false;
            stopBackgroundAudio();
            currentAbortControllers = [];
            hideStopButton();
            renderConversation();
            saveToStorage();
        }

        async function continueResponse(index) {
            const msg = currentConversation[index];
            if (msg.role !== 'assistant') return;
            if (isStreaming) return;

            // Find which model generated this response
            let model = null;

            if (msg.modelName) {
                model = models.find(m => m.name === msg.modelName);
                if (!model) {
                    // Try to find by model_id if name doesn't match
                    model = models.find(m => stripCompanyPrefix(m.name) === stripCompanyPrefix(msg.modelName));
                }
                if (!model) {
                    alert(`Cannot continue: model "${msg.modelName}" not found. Using first selected model instead.`);
                    const expandedIndices = expandModelEntries();
                    if (expandedIndices.length > 0) {
                        model = models[expandedIndices[0]];
                    } else {
                        alert('No models selected');
                        return;
                    }
                }
            } else if (getTotalModelInstances() > 0) {
                model = models[expandModelEntries()[0]];
            } else {
                alert('Cannot continue: No models selected');
                return;
            }

            // Truncate conversation to this message (inclusive) - remove any messages after it
            currentConversation = currentConversation.slice(0, index + 1);

            // Store the current content as prefill
            const prefillContent = msg.content || '';

            renderConversation();
            saveToStorage();

            // Start streaming continuation
            isStreaming = true;
            userStoppedGeneration = false;
            currentAbortControllers = [];
            showStopButton();
            startBackgroundAudio();

            try {
                // Use prefill streaming to continue from where the message left off
                await streamResponseWithPrefill(model, msg, prefillContent);
            } catch (error) {
                console.error('Continue error:', error);
                if (!msg.content) {
                    msg.content = 'Error: ' + error.message;
                }
                renderConversation();
            }

            isStreaming = false;
            stopBackgroundAudio();
            currentAbortControllers = [];
            hideStopButton();
            saveToStorage();
            renderConversation();
        }

        async function regenerateResponse(index) {
            const msg = currentConversation[index];
            if (msg.role !== 'assistant') return;
            if (isStreaming) return;

            // Find which model generated this response
            let model = null;

            if (msg.modelName) {
                // Find the model by name
                model = models.find(m => m.name === msg.modelName);
                if (!model) {
                    alert(`Cannot regenerate: model "${msg.modelName}" not found in your saved models`);
                    return;
                }
            } else if (getTotalModelInstances() === 1) {
                // If only one model selected, use that
                model = models[expandModelEntries()[0]];
            } else if (getTotalModelInstances() > 1) {
                // Multiple models but no modelName - ask user to select
                alert('Cannot regenerate: Multiple models selected but original model not identified. This may be an old message.');
                return;
            } else {
                alert('Cannot regenerate: No models selected');
                return;
            }

            // Truncate conversation to just before this message
            currentConversation = currentConversation.slice(0, index);

            // Create new assistant message for regeneration
            const assistantMessage = {
                role: 'assistant',
                content: '',
                thinking: '',
                modelName: model.name,
                timestamp: new Date().toISOString()
            };

            currentConversation.push(assistantMessage);
            renderConversation();
            saveToStorage();

            // Regenerate the response
            isStreaming = true;
            userStoppedGeneration = false; // Reset the stop flag
            currentAbortControllers = [];
            showStopButton();
            startBackgroundAudio(); // Keep iOS active during generation

            try {
                await streamResponse(model, assistantMessage);
            } catch (error) {
                console.error('Regeneration error:', error);
                assistantMessage.content = 'Error: ' + error.message;
                renderConversation();
            }

            isStreaming = false;
            stopBackgroundAudio(); // Stop silent audio when done
            currentAbortControllers = [];
            hideStopButton();
            saveToStorage();
            renderConversation();
        }

        // Lazy-load KaTeX (CSS + JS)
        let katexLoaded = false;
        async function loadKaTeX() {
            if (katexLoaded || typeof katex !== 'undefined') {
                katexLoaded = true;
                return;
            }

            // Load CSS
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
            document.head.appendChild(link);

            // Load JS
            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });

            katexLoaded = true;
        }

        // Lazy-load marked.js
        let markedLoaded = false;
        async function loadMarked() {
            if (markedLoaded || typeof marked !== 'undefined') {
                markedLoaded = true;
                return;
            }

            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/marked@12.0.0/marked.min.js';
                script.onload = () => {
                    // Configure marked for security and style
                    marked.setOptions({
                        breaks: true,  // Convert \n to <br>
                        gfm: true      // GitHub Flavored Markdown
                    });
                    resolve();
                };
                script.onerror = reject;
                document.head.appendChild(script);
            });

            markedLoaded = true;
        }

        function renderMarkdownWithLatex(text) {
            if (!text) return '';

            // Trim trailing whitespace to prevent extra <br> tags from marked
            text = text.trimEnd();

            // If neither rendering is enabled, just escape and return
            if (!enableLatexRendering && !enableMarkdownRendering) {
                return escapeHtml(text);
            }

            // Use null byte delimiters for masks (won't appear in normal text)
            const masks = [];
            let processed = text; // Work with RAW text first (fixes double-escaping)

            // 1. Mask fenced code blocks on raw text (captures language specifier separately)
            processed = processed.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                const id = masks.length;
                masks.push({ type: 'fenced', lang: lang || '', code: code });
                return `\x00MASK${id}\x00`;
            });

            // 2. Mask inline code on raw text (now supports content with newlines)
            processed = processed.replace(/`([^`]+)`/g, (match, code) => {
                const id = masks.length;
                masks.push({ type: 'inline', code: code });
                return `\x00MASK${id}\x00`;
            });

            // 3. Mask [Thinking: ...] blocks
            processed = processed.replace(/\[Thinking:[\s\S]+?\]/g, m => {
                const id = masks.length;
                masks.push({ type: 'thinking', content: m });
                return `\x00MASK${id}\x00`;
            });

            // 4. Mask and render LaTeX on raw text (fixes HTML entity issues in LaTeX)
            if (enableLatexRendering && typeof katex !== 'undefined') {
                // Block LaTeX: \[...\] and $$...$$
                processed = processed.replace(/\\\[([\s\S]+?)\\\]/g, (match, latex) => {
                    const id = masks.length;
                    try {
                        const rendered = katex.renderToString(latex.trim(), { throwOnError: false, displayMode: true });
                        masks.push({ type: 'latex-rendered', html: rendered });
                    } catch (e) {
                        masks.push({ type: 'latex-failed', raw: match });
                    }
                    return `\x00MASK${id}\x00`;
                });
                processed = processed.replace(/\$\$([\s\S]+?)\$\$/g, (match, latex) => {
                    const id = masks.length;
                    try {
                        const rendered = katex.renderToString(latex.trim(), { throwOnError: false, displayMode: true });
                        masks.push({ type: 'latex-rendered', html: rendered });
                    } catch (e) {
                        masks.push({ type: 'latex-failed', raw: match });
                    }
                    return `\x00MASK${id}\x00`;
                });
                // Inline LaTeX: \(...\)
                processed = processed.replace(/\\\(([\s\S]+?)\\\)/g, (match, latex) => {
                    const id = masks.length;
                    try {
                        const rendered = katex.renderToString(latex.trim(), { throwOnError: false, displayMode: false });
                        masks.push({ type: 'latex-rendered', html: rendered });
                    } catch (e) {
                        masks.push({ type: 'latex-failed', raw: match });
                    }
                    return `\x00MASK${id}\x00`;
                });
                // Single $...$ - require non-space adjacent to delimiters to reduce false positives
                // This prevents "$5 and $10" from matching, but "$x$" and "$x + y$" still work
                processed = processed.replace(/\$([^\$\s](?:[^\$]*[^\$\s])?)\$/g, (match, latex) => {
                    // Additional check: skip if this looks like a price (digit followed by non-math)
                    if (/^\d+(?:\.\d+)?$/.test(latex)) {
                        return match; // Don't convert plain numbers like $5$ or $10.50$
                    }
                    const id = masks.length;
                    try {
                        const rendered = katex.renderToString(latex.trim(), { throwOnError: false, displayMode: false });
                        masks.push({ type: 'latex-rendered', html: rendered });
                    } catch (e) {
                        masks.push({ type: 'latex-failed', raw: match });
                    }
                    return `\x00MASK${id}\x00`;
                });
            }

            // 5. NOW escape the remaining text (everything except masked regions)
            processed = escapeHtml(processed);

            // 6. Process markdown on escaped text (safe - no XSS since we don't unescape!)
            if (enableMarkdownRendering && typeof marked !== 'undefined') {
                processed = marked.parse(processed);
            }

            // 7. Restore all masked content
            processed = processed.replace(/\x00MASK(\d+)\x00/g, (match, i) => {
                const mask = masks[+i];
                if (!mask) return escapeHtml(match); // Safety: if mask doesn't exist, escape the placeholder

                switch (mask.type) {
                    case 'fenced': {
                        // Strip leading newline from code if present
                        let code = mask.code;
                        if (code.startsWith('\n')) code = code.slice(1);
                        if (code.endsWith('\n')) code = code.slice(0, -1);
                        const langAttr = mask.lang ? ` data-lang="${escapeHtml(mask.lang)}"` : '';
                        return `<pre style="background: #2a2a2a; padding: 12px; border-radius: 6px; overflow-x: auto; margin: 8px 0;"${langAttr}><code>${escapeHtml(code)}</code></pre>`;
                    }
                    case 'inline':
                        return `<code style="background: #3a3a3a; padding: 2px 6px; border-radius: 3px;">${escapeHtml(mask.code)}</code>`;
                    case 'thinking':
                        return escapeHtml(mask.content);
                    case 'latex-rendered':
                        return mask.html; // KaTeX output is safe HTML
                    case 'latex-failed':
                        return escapeHtml(mask.raw);
                    default:
                        return escapeHtml(match);
                }
            });

            return processed;
        }

        function renderHistory() {
            const list = document.getElementById('history-list');
            let html = '';

            // Show current conversation
            if (currentConversation.length > 0) {
                const summary = currentConversation.slice(0, 2).map(msg => {
                    if (msg.role === 'user') return 'User: ' + msg.content.substring(0, 50);
                    return 'Assistant: ' + msg.content.substring(0, 50);
                }).join('\n');

                html += `
                    <div class="history-item">
                        <h4>Current Conversation</h4>
                        <div style="white-space: pre-wrap; font-size: 13px; color: #aaa;">${escapeHtml(summary)}...</div>
                        <div style="color: #666; font-size: 12px; margin-top: 8px;">${currentConversation.length} messages</div>
                        <div class="history-actions">
                            <button onclick="exportConversation()">Export</button>
                            <button onclick="clearConversation()">Clear</button>
                        </div>
                    </div>
                `;
            }

            // Show saved conversation history
            if (conversationHistory.length > 0) {
                html += '<h3 style="margin-top: 20px; margin-bottom: 12px; color: #4a9eff;">Saved Conversations</h3>';

                conversationHistory.forEach((entry, index) => {
                    const date = new Date(entry.timestamp);
                    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                    const summary = entry.conversation.slice(0, 2).map(msg => {
                        if (msg.role === 'user') return 'User: ' + (msg.content || '').substring(0, 50);
                        return 'Assistant: ' + (msg.content || '').substring(0, 50);
                    }).join('\n');

                    html += `
                        <div class="history-item">
                            <h4>${escapeHtml(dateStr)}</h4>
                            <div style="white-space: pre-wrap; font-size: 13px; color: #aaa;">${escapeHtml(summary)}...</div>
                            <div style="color: #666; font-size: 12px; margin-top: 8px;">${entry.messageCount} messages</div>
                            <div class="history-actions">
                                <button onclick="loadConversation(${index})">Load</button>
                                <button onclick="exportHistoryItem(${index})">Export</button>
                                <button onclick="deleteHistoryItem(${index})">Delete</button>
                            </div>
                        </div>
                    `;
                });
            }

            if (!html) {
                html = '<p style="color: #888;">No conversation history yet. Start a chat and click "New Chat" to save it.</p>';
            }

            list.innerHTML = html;
        }

        function loadConversation(index) {
            if (!confirm('Load this conversation? Current conversation will be replaced.')) return;

            const entry = conversationHistory[index];
            if (entry) {
                currentConversation = [...entry.conversation];
                saveToStorage();
                renderConversation();
                renderHistory();
                switchTab('chat');
            }
        }

        function exportHistoryItem(index) {
            const entry = conversationHistory[index];
            if (entry) {
                const data = {
                    conversation: entry.conversation,
                    timestamp: entry.timestamp
                };
                downloadJSON(data, `conversation-${entry.id}.json`);
            }
        }

        function deleteHistoryItem(index) {
            if (!confirm('Delete this conversation from history?')) return;

            conversationHistory.splice(index, 1);
            saveToStorage();
            renderHistory();
        }

        function newChat() {
            if (currentConversation.length > 0) {
                // Automatically save current conversation to history
                const historyEntry = {
                    id: Date.now().toString(),
                    timestamp: new Date().toISOString(),
                    conversation: [...currentConversation],
                    messageCount: currentConversation.length
                };
                conversationHistory.unshift(historyEntry); // Add to beginning of array

                // Keep only last 50 conversations to avoid excessive storage
                if (conversationHistory.length > 50) {
                    conversationHistory = conversationHistory.slice(0, 50);
                }
            }

            currentConversation = [];
            attachedFiles = [];
            editingMessageIndex = null;
            showEditIndicator(false);
            saveToStorage();
            renderConversation();
            renderHistory();
            renderAttachedFiles();
            document.getElementById('message-input').value = '';
        }

        function clearConversation() {
            if (!confirm('Clear current conversation?')) return;
            currentConversation = [];
            saveToStorage();
            renderConversation();
            renderHistory();
        }

        function clearHistory() {
            if (!confirm('Clear ALL conversation history? This will delete all saved conversations and cannot be undone.')) return;
            conversationHistory = [];
            currentConversation = [];
            attachedFiles = [];
            editingMessageIndex = null;
            showEditIndicator(false);
            saveToStorage();
            renderConversation();
            renderHistory();
            renderAttachedFiles();
            document.getElementById('message-input').value = '';
        }

        function exportConversation() {
            const data = {
                conversation: currentConversation,
                timestamp: new Date().toISOString()
            };
            downloadJSON(data, `conversation-${Date.now()}.json`);
        }

        function importHistory(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (data.conversation && Array.isArray(data.conversation)) {
                        // Replace current conversation with imported one
                        currentConversation = data.conversation;
                        saveToStorage();
                        renderConversation();
                        renderHistory();
                        alert('History imported successfully!');
                        // Switch to chat tab to see the imported conversation
                        switchTab('chat');
                    } else {
                        alert('Invalid history file format. Expected a conversation array.');
                    }
                } catch (e) {
                    alert('Error importing history: ' + e.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function exportData() {
            const data = {
                models,
                apiKeys,
                systemPrompts,
                activePromptId,
                currentConversation,
                selectedModelEntries,
                multiModelMode,
                iterationCount,
                messageHistoryLimit,
                includeFilesInHistory,
                responseDelay,
                enableModelIdentity,
                enableBackgroundAudio,
                enableExtendedThinking,
                enableLatexRendering,
                enableMarkdownRendering,
                thinkingEffort,
                userIdentifier,
                conversationHistory,
                exportDate: new Date().toISOString()
            };
            downloadJSON(data, `api-chat-backup-${Date.now()}.json`);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    // Core data
                    if (data.models) models = data.models;
                    if (data.apiKeys) apiKeys = data.apiKeys;
                    if (data.systemPrompts) systemPrompts = data.systemPrompts;
                    if ('activePromptId' in data) activePromptId = data.activePromptId;
                    if (data.currentConversation) currentConversation = data.currentConversation;
                    if (data.conversationHistory) conversationHistory = data.conversationHistory;

                    // Model selection
                    if (data.selectedModelEntries) selectedModelEntries = data.selectedModelEntries;
                    if (data.multiModelMode) multiModelMode = data.multiModelMode;
                    if ('iterationCount' in data) iterationCount = data.iterationCount;

                    // Settings
                    if ('messageHistoryLimit' in data) messageHistoryLimit = data.messageHistoryLimit;
                    if ('includeFilesInHistory' in data) includeFilesInHistory = data.includeFilesInHistory;
                    if ('responseDelay' in data) responseDelay = data.responseDelay;
                    if ('enableModelIdentity' in data) enableModelIdentity = data.enableModelIdentity;
                    if ('enableBackgroundAudio' in data) enableBackgroundAudio = data.enableBackgroundAudio;
                    if ('enableExtendedThinking' in data) enableExtendedThinking = data.enableExtendedThinking;
                    if ('enableLatexRendering' in data) enableLatexRendering = data.enableLatexRendering;
                    if ('enableMarkdownRendering' in data) enableMarkdownRendering = data.enableMarkdownRendering;
                    if (data.thinkingEffort) thinkingEffort = data.thinkingEffort;
                    if (data.userIdentifier) userIdentifier = data.userIdentifier;

                    await saveToStorage();
                    await init();
                    alert('Data imported successfully!');
                } catch (e) {
                    alert('Error importing data: ' + e.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function sanitizeFileName(name) {
            if (!name || typeof name !== 'string') return 'unnamed-file';
            let sanitized = name.replace(/[\r\n\t]+/g, ' ').replace(/\s+/g, ' ').trim();
            if (sanitized.length > 100) sanitized = sanitized.slice(0, 100) + '...';
            return sanitized || 'unnamed-file';
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
